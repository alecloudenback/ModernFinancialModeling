---
author:
  - name: Alec Loudenback
  - name: Yun-Tien Lee
---

# Data and Types {#sec-data-types}

> I am only one, but I am one. I can't do everything, but I can do something. The something I ought to do, I can do. And by the grace of God, I will - Edward Everett Hale (1902)

## Chapter Overview

Using Julia’s type system lets us express financial instruments and valuation logic cleanly and efficiently. In this chapter we will:
-  model assets as concrete types within a simple hierarchy,
-  define valuation functions using multiple dispatch,
-  show how to aggregate portfolio value succinctly,
-  compare this data-oriented approach with common object-oriented patterns.

## Using Types to Value a Portfolio

We'll assemble the tools and terminology to value a portfolio of assets by leveraging Julia's type system. Using the constructs from the prior chapter, we can describe portfolio valuation as mapping a value function over assets and summing the results. We aim to compute total portfolio value by applying a valuation function to each asset and summing the individual valuations:

``` julia
mapreduce(value,+,portfolio)
```

The challenge: how do we design an all-purpose `value` function? Assets in `portfolio` may be heterogeneous, so we need to define valuation semantics for different asset types. To reach our end goal, we need to:

1.  Define the different kinds of assets within our portfolio
2.  How the assets are to be valued.

We will accomplish this by utilizing data types.

## Benefits of Using Types

As a preview of why we want to utilize types in our program, there are a number of benefits:

1.  **Separate concerns**. For example, deciding how to value an option need not know how we value a bond. The code and associated logic is kept distinct which is easier to reason about and to test.
2.  **Re-use code**. When a set of types within a hierarchy all share the same logic, then we can define the method at the highest relevant level and avoid writing the method for each possible type. In our simple example we won't get as much benefit here since the hierarchy is simple and the set of types small.
3.  **Extensibility through dispatch**`\index{polymorphism}`{=latex}. By defining types for our assets, we can use multiple dispatch to define specialized behavior for each type. This allows us to write generic code that works with any asset type, and the Julia compiler will automatically select the appropriate method based on the type of the asset at runtime. This is a powerful feature that enables extensibility and modularity in our code.
4.  **Improve readability and clarity**. By defining types for our assets, we make our code more expressive and self-documenting. The types provide a clear indication of what kind of data we are working with, making it easier for other developers (or ourselves in the future) to understand and maintain the codebase.
5.  **Enable type safety**. By specifying the expected types for function arguments and return values, we can catch type-related errors at compile time rather than at runtime. This helps prevent bugs and makes our code more robust.

With these benefits in mind, let's start by defining the types for our assets. We'll create an abstract type called Asset that will serve as the parent type for all our asset types. If you haven't read it already, @sec-user-defined-types is a good reference for details on types at the language level (this section is focused on organization and building up the abstracted valuation process).

## Defining Types for Portfolio Valuation

We will define two types of assets in this simplified universe:

-   Cash
-   Risk-free Bonds (coupon and zero-coupon varieties)

To do the valuation of these, we need some economic parameters as well: risk free rates for discounting.

Here's the outline of what follows to get an understanding of types, type hierarchy, and multiple dispatch.

1.  Define the Cash and Bond types.
2.  Define the most basic economic parameter set.
3.  Define the `value` functions for Cash and Bonds.

```{julia}
#| output: false

## Data type definitions
abstract type AbstractAsset end #<1>

struct Cash <: AbstractAsset # <3>
    balance::Float64
end

abstract type AbstractBond <: AbstractAsset end #<2>

struct CouponBond <: AbstractBond #<3>
    par::Float64
    coupon::Float64
    tenor::Int
end

struct ZeroCouponBond <: AbstractBond #<3>
    par::Float64
    tenor::Int
end
```

1.  General convention is to name abstract types beginning with `Abstract...`
2.  There can exist an abstract type which is a subtype of another abstract type.
3.  We define concrete data types (`structs`) with the fields necessary for valuing those assets.

Now to define the economic parameters:

```{julia}
struct EconomicAssumptions{T}
  riskfree::T
end
```

This is a parametric type because later on we will vary what objects we use for `riskfree`. For now, we will use simple scalar values, like in this potential scenario:

```{julia}
econ_baseline = EconomicAssumptions(0.05)
```

Now on to defining the valuation for `Cash` and `AbstractBonds`. Cash is always equal to its balance:

```{julia}
value(asset::Cash, econ::EconomicAssumptions) = asset.balance
```

Risk free bonds are the discounted present value of the riskless cashflows. We first define a method that generically operates on any fixed bond, all that's left to do is for different types of bonds to define how much cashflow occurs at the given point in time by defining `cashflow` for the associated type.

```{julia}
function value(asset::AbstractBond, r::Float64) # <2>
    discount_factor = 1.0
    pv = 0.0
    for t in 1:asset.tenor
        discount_factor /= (1 + r) # <1>
        pv += discount_factor * cashflow(asset, t)
    end
    return pv
end

function cashflow(bond::CouponBond, time)
    if time == bond.tenor
        (1 + bond.coupon) * bond.par
    else
        bond.coupon * bond.par
    end
end

function value(bond::ZeroCouponBond, r::Float64) # <3>
    return bond.par / (1 + r)^bond.tenor
end

```

1.  `x /= y`, `x += y`, etc. are shorthand ways to write `x = x / y` or `x = x + y`
2.  `value` is defined for `AbstractBond`s in general...
3.  ... and then more specifically for `ZeroCouponBond`s. This will be explained when discussing "dispatch" below.


### Dispatch

When a function is called, the computer has to decide which method to use. In the example above, when we want to `value` a `ZeroCouponBond`, does the `value(asset::AbstractBond, r)` or `value(bond::ZeroCouponBond, r)` version get used?

**Dispatch**`\index{dispatch}`{=latex} is the process of determining the right method to use and the rule is that *the most specific defined method gets used*. In this case, that means that even though our `ZeroCouponBond` is an `AbstractBond`, the routine that will be used is the most specific `value(bond::ZeroCouponBond, r)`.

Already, this is a powerful tool to simplify our code. Imagine the alternative of a long chain of conditional statements trying to find the right logic to use:

``` julia
# don't do this!
function value(asset,r)
    if asset.type == "ZeroCouponBond"
        # special code for Zero coupon bonds
        # ...
    elseif asset.type == "ParBond"
        # special code for Par bonds
        # ...
    elseif asset.type == "AmortizingBond"
        # special code for Amortizing Bonds
        # ...
    else
        # here define the generic AbstractBond logic
    end
end
```

With dispatch, the compiler does this lookup for us, and more efficiently than enumerating a list of possible codepaths.

In contrast with the prior code example, we didn't have a long chain of `if` statements, and instead are letting the types themselves dictate which functions are relevant and will be called. We provided a generic `value` function for any `AbstractBond` which loops through time, and a specialized one for `ZeroCouponBond`.

We *could* have simply used the generic `AbstractBond` method for the `ZeroCouponBond` as well. To do so, we would only need to define its `cashflow` method:

```julia
# An alternative, but less efficient, implementation
function cashflow(bond::ZeroCouponBond, time)
    # A zero-coupon bond only pays its par value at the very end
    if time == bond.tenor
        return bond.par
    else
        return 0.0
    end
end
```

With this method, the generic `value` function would have worked correctly, looping from `t=1` to `t=tenor` and finding only a single non-zero cashflow to discount.

However, this is inefficient. We know there is a more direct, closed-form formula to value a zero-coupon bond: $PV = \frac{\text{Par}}{(1+r)^\text{tenor}}$. There's no need to loop through intermediate years where the cashflow is zero.

This is the power of dispatch. By defining a **more specific** method, `value(bond::ZeroCouponBond, r::Float64)`, we are telling Julia: "When you have a `ZeroCouponBond`, use this highly efficient, direct formula. For any *other* kind of `AbstractBond`, you can fall back on the generic looping version." Dispatch ensures that the most specific, and in this case most performant, implementation is automatically chosen. This allows you to build a system that is both general and extensible, while also being highly optimized for the most common and simple cases.


#### Integrating Economic Assumptions


Despite the definitions above, the following will error because we haven't defined a method for `value` which takes as its second argument a type of `EconomicAssumptions`:

``` julia
#| error: true
value(ZeroCouponBond(100.0,5),econ_baseline)
```

Let's fix that by defining a method which takes the economic assumption type and just relays the relevant risk free rate to the `value` methods already defined (which take an `AbstractBond` and a scalar `r`).

```{julia}
value(bond::AbstractBond,econ::EconomicAssumptions) = value(bond,econ.riskfree)
```

Now this following works:

```{julia}
value(ZeroCouponBond(100.0, 5), econ_baseline)
```

Here's an example of how this would be used:

```{julia}
portfolio = [
    Cash(50.0),
    CouponBond(100.0, 0.05, 5),
    ZeroCouponBond(100.0, 5),
]

map(asset-> value(asset,econ_baseline), portfolio)
```

This is very close to the goal that we set out at the end of the section. We can complete it by reducing over the collection to sum up the value:

```{julia}
mapreduce(asset -> value(asset,econ_baseline), +, portfolio)
```

::: callout-note
This code:

```
mapreduce(asset-> value(asset,econ_baseline), +, portfolio)
```

is more verbose than what we set out to do at the start (`mapreduce(value,+,portfolio)`) due to the two-argument `value` function requiring a second argument for the economic variables. This works well! However, there is a way to define it which avoids the anonymous function, which in some cases will end up needing to be compiled more frequently than you want it to. Sometimes we want a lightweight, okay-to-compile-on-the-fly function. Other times, we know it's something that will be passed around in compute-intensive parts of the code. 

A technique in this situation is to define an object that "locks in" one of the arguments but behaves like the anonymous version. There is a pair of types in the Base module, `Fix1` and `Fix2`, which represent partially-applied versions of the two-argument function f, with the first or second argument fixed to the value "x".

That is, `Base.Fix1(f, x)` behaves like `y->f(x, y)` and `Base.Fix2(f, x)` behaves like `y->f(y, x)`.

In the context of our valuation model, this would look like:

```{julia}
val = Base.Fix2(value,econ_baseline)
mapreduce(val,+,portfolio)
```
:::

#### Multiple Dispatch

A more general concept is that of **multiple dispatch**`\index{multiple dispatch}`{=latex}, where the types of *all arguments* are used to determine which method to use. This is a very general paradigm, and in many ways is more extensible than traditional object oriented approaches, (more on that in @sec-object-oriented). What if instead of a scalar interest rate value we wanted to instead pass an object that represented a term structure of interest rates?

Extending the example, we can use a time-varying risk free rate instead of a constant. For fun, let's say that the risk free rate has a sinusoidal pattern:

```{julia}
econ_sin = EconomicAssumptions(t -> 0.05 + sin(t) / 100)
```

Now `value` will not work, because we've only defined how `value` works on bonds if the given rate is a `Float64` type:

```{julia}
#| error: true
value(ZeroCouponBond(100.0, 5), econ_sin)
```

We can extend our methods to account for this:

```{julia}
function value(bond::ZeroCouponBond, r::Function) # <1>
    return bond.par / (1 + r(bond.tenor))^bond.tenor # <2>
end
```

1.  The `r::Function` constraint says use this method if `r` is any subtype of the (abstract) `Function` type.
2.  `r` is a function that we call with the time to get the zero coupon bond (a.k.a. spot) rate for the given timepoint.

Now it works:

```{julia}
value(ZeroCouponBond(100.0, 5), econ_sin)
```

The important thing to note here is that the compiler is using the most specific method of the function (`value(bond::ZeroCouponBond, r::Function)`). Both the types of the arguments are influencing the decision of which method to use. To complete the example for `CouponBond`, we would need to define a similar method that calls `r(t)` at each coupon date within the valuation loop.

## Object-Oriented Design {#sec-object-oriented}

Object-oriented (OO)`\index{object-oriented programming}`{=latex} type systems use the analogy that various parts of the system are their own objects that encapsulate both data and behavior. Object oriented design is often one of the first computer programming abstractions introduced because it is very relatable[^type-abstractions-1], however there are a number of flaws in over-relying on OO patterns. Julia does not natively have traditional OO classes and types, but much of OO design can be emulated in Julia except for data inheritance.

[^type-abstractions-1]: "Many people who have no idea how a computer works find the idea of object-oriented programming quite natural. In contrast, many people who have experience with computers initially think there is something strange about object oriented systems.” - David Robson, "Object Oriented Software Systems" in Byte Magazine (1981).

::: callout-note
For readers without background in OO programming, the main features of OO languages are:

-   Hierarchical type structures, which include concrete and abstract (often called classes instead of types).

-   Sub-classes inherit both behavior *and* data (in Julia, subtypes only inherit behavior, not data).

-   Functions that depend on the type of the object need to be ascribed to a single class and then can dispatch more specifically on the given argument's type.
:::

We bring up object-oriented design for comparison's sake, but think that ultimately choosing a data-driven or functional design is better for financial modeling. Of course, many robust, well-used financial models have been built this way but in our experience the abstractions become unnatural. Additionally, maintenance becomes unwieldy beyond simple examples. We'll now discuss some of the aspects of OO design and why the overuse of OO is not preferred.

### Assigning Behavior

Needing to assign methods to a single class can lead to awkward design limitations - when multiple objects are involved in a computation, why dictate that only one of them "controls" the logic?

The `value` function is a good example of this. If we had to assign `value` to one of the objects involved, should it be the economic parameter object or the asset objects? The choice is not obvious at all. Isn't it the market (economic parameters) that determines the value? But then if `value` were to be a method wholly owned by the economic parameters, how could it possibly define in advance the valuation semantics of all types of assets? What if one wanted to extend the valuation to a new asset class? Downstream users or developers would need to modify the economic types to handle new assets they wanted to value. However, because the economic types were owned by an upstream package, they can't be extended this way.

This is an issue with traditional OO designs and that resolves itself so elegantly with multiple dispatch.

#### Example: The Expression Problem

A fundamental limitation of OOP is what's called the **Expression Problem**`\index{expression problem}`{=latex}. The challenge (or problem) is that with OOP languages it is difficult to extend both datatypes *and* behavior. In the example that follows, we define types of insurance products with associated methods.

Here's the setup: we are modeling insurance contracts and someone has provided a nice library which we will call Insurance.jl and pyInsurance for a Julia and Python package. The package defines datatypes for Term and Whole Life insurance products, as well as a lot of utilities related to calculating premiums and reserves (i.e. performing valuations). Defining the functionality is straightforward enough in both languages/approaches:

:::::: {.columns .column-body-outset}
::: {.column width="43%"}
**Insurance.jl**

A hypothetical package available for your use.

``` julia
abstract type InsuranceProduct end

struct TermLife <: InsuranceProduct
    term::Int
    face_amount::Float64
    age::Int
end

struct WholeLife <: InsuranceProduct
    face_amount::Float64
    age::Int
end

# Calculate premium
premium(p::TermLife) = ...
premium(p::WholeLife) = ...

# Calculate reserves
reserve(p::TermLife, t::Int) = ...
reserve(p::WholeLife, t::Int) = ...
```

\
:::

::: {.column width="4%"}
:::

::: {.column width="53%"}
**pyInsurance**

A hypothetical package available for your use.

``` python
from abc import ABC, abstractmethod
from dataclasses import dataclass

class InsuranceProduct(ABC):
    @abstractmethod
    def calculate_premium(self) -> float:
        pass
    
    @abstractmethod
    def calculate_reserve(self, t: int) -> float:
        pass

@dataclass
class TermLife(InsuranceProduct):
    term: int
    face_amount: float
    age: int

    # Term-specific calculations
    def calculate_premium(self) -> float:
        return ...
    
    def calculate_reserve(self, t: int) -> float:
        return ...

@dataclass
class WholeLife(InsuranceProduct):
    face_amount: float
    age: int

    # WholeLife-specific calculations
    def calculate_premium(self) -> float:
        return ...
    
    def calculate_reserve(self, t: int) -> float:
        return ...
```
:::
::::::

Now, say that we want to utilize this package and extend the behavior. Specifically, we want to add a Deferred Annuity type and add functionality (for all products) related to determining a cash surrender value.

We run into limitations with Python version. We can extend a new representation (dataclass), but adding new functionality (e.g. `cash_value`) requires modifying other classes which you may not own and for which the method may not apply.

:::::: {.columns .column-body-outset}
::: {.column width="43%"}
**Julia (Multiple Dispatch)**

``` julia
struct DeferredAnnuity <: InsuranceProduct
    premium::Float64
    deferral_period::Int
    age::Int
end

# Implement existing methods
premium(p::DeferredAnnuity) = ...
reserve(p::DeferredAnnuity, t::Int) = ...

# Adding new function
cash_value(p::WholeLife, t::Int) = ...
cash_value(p::DeferredAnnuity, t::Int) = ...
```
:::

::: {.column width="4%"}
:::

::: {.column width="53%"}
**Python (Object-Oriented)**

``` python
@dataclass
class DeferredAnnuity(InsuranceProduct):
    premium: float
    deferral_period: int
    age: int
    
    def calculate_premium(self) -> float:
        # Annuity-specific premium calc
        return ...
    
    def calculate_reserve(self, t: int) -> float:
        # Annuity-specific reserve calc
        return ...
```
:::
::::::

There are workarounds to handle this, which include those listed in @tbl-OOP-workarounds.

::: landscape
+---------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| Workaround to OOP Expression Problem                                                  | Concerns with Workaround                                                                                                                                                                                                                                          |
+=======================================================================================+===================================================================================================================================================================================================================================================================+
| **Monkey-Patching**                                                                   | -   **Overwriting Conflicts:** If two different parts of a program try to patch the same method, the last one to run will overwrite the others. This can disable expected functionality in a way that is difficult to predict.                                    |
|                                                                                       | -   **Harder to Debug:** Patching makes the code's runtime behavior different from its source code. This complicates debugging because the written code no longer represents what is actually happening.                                                          |
| You can dynamically inject the method into the library's class definition at runtime. | -   **Upgrade Instability:** A patch may break when the underlying code it modifies is updated. This creates a maintenance burden, as patches need to be re-validated and potentially re-written with each library upgrade.                                       |
|                                                                                       |                                                                                                                                                                                                                                                                   |
| ``` python                                                                            |                                                                                                                                                                                                                                                                   |
| # WARNING: This is generally considered bad practice                                  |                                                                                                                                                                                                                                                                   |
| from ultimate_insurance_models import WholeLife                                       |                                                                                                                                                                                                                                                                   |
|                                                                                       |                                                                                                                                                                                                                                                                   |
| def _calculate_cash_value_for_wholelife(self, t: int) -> float:                       |                                                                                                                                                                                                                                                                   |
|   return ...                                                                          |                                                                                                                                                                                                                                                                   |
|                                                                                       |                                                                                                                                                                                                                                                                   |
| # At the start of your app, "patch" the library's class                               |                                                                                                                                                                                                                                                                   |
| WholeLife.calculate_cash_value = _calculate_cash_value_for_wholelife                  |                                                                                                                                                                                                                                                                   |
|                                                                                       |                                                                                                                                                                                                                                                                   |
| wl_policy = WholeLife(face_amount=500000, age=40)                                     |                                                                                                                                                                                                                                                                   |
| wl_policy.calculate_cash_value(t=10)                                                  |                                                                                                                                                                                                                                                                   |
| ```                                                                                   |                                                                                                                                                                                                                                                                   |
+---------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| **Subclassing**                                                                       | -   **Incomplete Coverage:** The new functionality only exists on your subclass. Any code that creates an instance of the original parent class will produce an object that lacks your new methods.                                                               |
|                                                                                       | -   **Breaks Polymorphism:** It forces you to check an object's specific type before using the new functionality (e.g., using isinstance). This defeats the purpose of having a common interface and makes the code more complex and less robust.                 |
| You can inherit from the parent class to create your own custom version.              | -   **Doesn't Affect Object Creation:** Functions within the original library will continue to create and return instances of the original parent class. You cannot alter this behavior, meaning objects created by the library will not have your added methods. |
|                                                                                       |                                                                                                                                                                                                                                                                   |
| ``` python                                                                            |                                                                                                                                                                                                                                                                   |
| from ultimate_insurance_models import WholeLife                                       |                                                                                                                                                                                                                                                                   |
|                                                                                       |                                                                                                                                                                                                                                                                   |
| class MyExtendedWholeLife(WholeLife):                                                 |                                                                                                                                                                                                                                                                   |
|   def calculate_cash_value(self, t: int) -> float:                                    |                                                                                                                                                                                                                                                                   |
|     # Your brilliant logic                                                            |                                                                                                                                                                                                                                                                   |
|     return self.face_amount * 0.1 * t                                                 |                                                                                                                                                                                                                                                                   |
|                                                                                       |                                                                                                                                                                                                                                                                   |
| # You have to make sure you ONLY create your extended version                         |                                                                                                                                                                                                                                                                   |
| my_policy = MyExtendedWholeLife(face_amount=500000, age=40)                           |                                                                                                                                                                                                                                                                   |
| ```                                                                                   |                                                                                                                                                                                                                                                                   |
+---------------------------------------------------------------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
: Workarounds for Object Oriented Programming restrictions. The object oriented paradigm does not allow for extension of **both** representation (data types) and behavior (methods). {#tbl-OOP-workarounds tbl-colwidths="[50,50]"}
:::


In Julia, functions are defined separately from data types. This allows you to add new functions to existing types—even those from external libraries—without altering their original code. Your new functionality works on all instances of the original type, avoiding both the conflicts of patching and the type-checking required by subclassing. Julia's multiple dispatch facilitates a more general, data-oriented approach.

### Inheritance

As seen in the prior example, in most OO implementations this hierarchy comes with inheriting`\index{inheritance}`{=latex} both data *and* behavior. This is different from Julia where subtypes inherit behavior but not data from the parent type.

Inheriting the data tends to introduce a tight coupling between the parent and the child classes in OO systems. This tight coupling can lead to several issues, particularly as systems grow in complexity. For example, changes in the parent class can inadvertently affect the behavior of all its child classes, which can be problematic if these changes are not carefully managed. This is often referred to as the "fragile base class problem," where base classes are delicate and changes to them can have widespread, unintended consequences.

Another issue with inheritance in OO design is the temptation to use it for code reuse, which can lead to inappropriate hierarchies. Developers might create deep inheritance structures just to reuse code, leading to a scenario where classes are not logically related but are forced into a hierarchy. This can make the system harder to understand and maintain.

#### Composition over Inheritance

To mitigate some of the problems associated with inheritance, there is a growing preference for *composition*`\index{composition over inheritance}`{=latex}. Composition involves creating objects that contain instances of other objects to achieve complex behaviors. This approach is more flexible than inheritance as it allows for the creation of more modular and reusable code.

To see why, consider a concrete problem: we want to model financial instruments that share *some* but not *all* characteristics. A municipal bond is a fixed-income instrument (it has a coupon and tenor), but it's also a listed security (it has a CUSIP identifier). An interest rate swap has fixed-income characteristics on both legs, but isn't a listed security at all. A listed equity option has a CUSIP but no fixed-income characteristics.

With inheritance, we'd be forced to choose a single parent for each type:

```julia
# The inheritance approach runs into trouble
abstract type Asset end
abstract type FixedIncomeAsset <: Asset end
abstract type ListedAsset <: Asset end

# But what is a MunicipalBond? It's both fixed income AND listed.
# We can only pick one parent:
struct MunicipalBond <: FixedIncomeAsset  # Can't also be <: ListedAsset
    # ...
end
```

There's no natural hierarchy here. A municipal bond isn't "more" of a fixed-income instrument than a listed security—it's both. Inheritance forces us to pick one lineage, and we lose the ability to share behavior along the other dimension.

Composition solves this by building types out of reusable components:

```{julia}
#| output: false
struct CUSIP
    code::String
end

struct FixedIncome
    coupon::Float64
    tenor::Int
end

struct FloatingRate
    spread::Float64
    tenor::Int
end
```

Now we can compose these building blocks into the instruments we need:

```{julia}
#| output: false
struct MunicipalBond      # Has both CUSIP and fixed-income characteristics
    cusip::CUSIP
    fi::FixedIncome
end

struct Swap               # Two legs, no CUSIP
    fixed_leg::FixedIncome
    float_leg::FloatingRate
end

struct ListedOption       # Has CUSIP, but no fixed-income component
    cusip::CUSIP
    strike::Float64
    expiry::Int
end

struct PrivatePlacement   # Fixed income, but not listed
    fi::FixedIncome
    counterparty::String
end
```

::: column-margin
A CUSIP`\index{CUSIP}`{=latex} (Committee on Uniform Security Identification Procedures) number is a unique nine-character alphanumeric code assigned to securities in the United States and Canada, used to identify them in clearing and settlement.
:::

The key insight is **delegation**: we define behavior on the component types, then delegate to those components from the composite types.

```{julia}
# Macaulay duration for a fixed-income component
function duration(fi::FixedIncome, rate)
    # Simplified duration calculation
    pv_weighted_time = 0.0
    pv_total = 0.0
    for t in 1:fi.tenor
        cf = t == fi.tenor ? (1 + fi.coupon) : fi.coupon
        pv = cf / (1 + rate)^t
        pv_weighted_time += t * pv
        pv_total += pv
    end
    return pv_weighted_time / pv_total
end

# Delegate: any type with a .fi field can compute duration
duration(asset::MunicipalBond, rate) = duration(asset.fi, rate)
duration(asset::PrivatePlacement, rate) = duration(asset.fi, rate)
```

Now we can use these:

```{julia}
muni = MunicipalBond(CUSIP("123456789"), FixedIncome(0.05, 10))
duration(muni, 0.04)
```

```{julia}
private = PrivatePlacement(FixedIncome(0.06, 5), "Acme Corp")
duration(private, 0.04)
```

The `MunicipalBond` and `PrivatePlacement` types share duration logic through their common `FixedIncome` component—not through a shared parent class. We could similarly define `lookup_trades(c::CUSIP)` and delegate to it from `MunicipalBond` and `ListedOption`, sharing that behavior along an orthogonal dimension.

**When is inheritance appropriate?** Inheritance works well for genuine "is-a" relationships where a single hierarchy makes sense. A `CouponBond` really *is* a kind of `Bond`—there's no ambiguity about where it belongs. The earlier portfolio valuation example in this chapter uses inheritance appropriately: `ZeroCouponBond <: AbstractBond <: AbstractAsset` is a clean hierarchy.

The rule of thumb: use inheritance when types form a natural tree. Use composition when types share characteristics along multiple independent dimensions—which is common in financial modeling, where instruments often combine features (listed vs. private, fixed vs. floating, secured vs. unsecured) in various combinations.

::: callout-tip
## Working with Nested Immutable Data

One practical consideration with composition: if your composite types are immutable (the default for `struct`), updating a nested field requires creating a new instance. The [Accessors.jl](https://github.com/JuliaObjects/Accessors.jl) package provides convenient syntax for this:

```julia
using Accessors
# Create a new MunicipalBond with a different coupon
updated_muni = @set muni.fi.coupon = 0.055
```

This returns a new `MunicipalBond` with the nested coupon changed, leaving the original unchanged.
:::

## Data-Oriented Design

Data-Oriented Programming (DOP)`\index{data-oriented design}`{=latex}, especially in a computational field like financial modeling, is an approach that prioritizes the data itself—its structure, its layout in memory, and how it’s processed in bulk. This stands in contrast to Object-Oriented Programming, which prioritizes encapsulating data within objects and interacting with that data through the object's methods.

DOP separates the data from the behavior:

1.  **Data is transparent and inert**. We define structures (like the `Cash` and `CouponBond` structs in our example) that are simple, transparent containers for information. Their job is to hold data, not to have complex internal logic.

2.  **Behavior is handled by functions**. Logic is implemented in generic functions (like our `value` function) that operate on this data.

The portfolio valuation model we have built in this chapter is an example of data-oriented design. We created a collection of data—the `portfolio` array. We then used Julia's functions (`mapreduce`, and our own `value` function) to transform that data into a final result. We can easily add a completely new operation, say `calculate_duration(asset, econ_assumptions)`, without ever modifying the original `struct` definitions for our assets.

This approach is pertinent for financial modeling for several key reasons:

-   **Flexibility:** Financial models require many different views of the same data. Today we need to `value` a portfolio. Tomorrow, we might need to calculate its credit risk, liquidity risk, or run a stress test. With a data-oriented approach, each new requirement is simply a new set of functions that we write to operate on the same underlying data structures. In a strict OO world, we might be forced to add a `.calculate_credit_risk()` method to every single asset class, which can become unwieldy.
-   **Performance:** Financial computations often involve applying a single operation to millions or billions of items (e.g., valuing every asset in a large portfolio, running a Monte Carlo simulation with millions of paths). DOP allows the data to be laid out in memory in a way that is highly efficient for modern CPUs or GPUs to process (e.g., in contiguous arrays). By processing data in bulk, we leverage how computer hardware is designed to work, leading to significant performance gains over designs that require calling methods on individual objects one by one.
-   **Simplicity and Scalability:** As a system grows, data-oriented designs can be easier to reason about. The "state" of the system is just the data itself. The logic is contained in pure functions that transform data. This avoids the complex webs of object relationships, inheritance hierarchies, and hidden state that can make large OO systems difficult to maintain and debug.

While object-oriented design patterns can be useful, for the performance-critical and mathematically intensive world of financial modeling, a data-oriented approach often proves to be a more natural, scalable, and efficient choice. It aligns perfectly with the core task: the transformation of data (market and instrument parameters) into insight (value, risk, etc.).