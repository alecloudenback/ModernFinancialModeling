# Elements of Programming {#sec-elements-programming}

> "Programming is not about typing, it's about thinking." — Rich Hickey (2011)

## In this section

Start building up computer science concepts by introducing tangible programming essentials. Data types, variables, control flow, functions, and scope are introduced.

## Computer Science, Programming, and Coding

Computer Science is the study of computing and information. As a science, it is distinct from programming languages which are merely coarse implementations of specific computer science concepts[^foundations-of-programming-1]. Programming (or "coding") is the art and science of writing code in programming languages to have the computer perform desired tasks. While this may sound mechanistic, programming truly is one of the highest forms of abstract thinking and the design space of potential solutions is so large and potentially complex that much art and experience is needed to create a well-made program.

[^foundations-of-programming-1]: Said differently, computer science may contemplate ideas and abstractions more generally than a specific implementation, as in mathematics where a theorem may be proved ($a^2 + b^2 = c^2$) without resorting to specific numeric examples ($3^2 + 4^2 = 5^2$).

The language of computer science also provides a lexicon so that financial practitioners can discuss model architecture and problem characteristics. Having the language to describe a concept will also help see aspects of the problem in new ways, opening one up to more innovative solutions.

In the context of this financial modeling that we do, we can consider a financial model to be a type of computer program. It takes as input abstract information (data), performs calculations (an algorithm), and returns new data as an output. In this context, we generally do not need to consider many things that a software engineer may contemplate such as a graphical user interface, networking, or access restrictions. But there are many similarities: a good financial modeler must understand data types, algorithms, and some hardware details.

We will build up the concepts over this and the following chapter:

-   This chapter will provide a survey of important concepts in computer science that will prove useful for our financial modeling. First, we will talk about data types, boolean logic, and basic expressions. We'll build on those to discuss algorithms (functions) which perform useful work and use control flow and recursion.
-   The following chapter will step back and discuss higher level concepts: the "schools of thought" around organizing the relationship between data and functions (functional versus object-oriented programming), design patterns, computational complexity, and compilation.

::: callout-tip
There will be brief references to hardware considerations for completeness, but hardware knowledge is not necessary to understand most programming languages (including Julia). It's impossible to completely avoid talking about hardware when you care about the performance of your code, so feel free to gloss over the reference to hardware details on the first read and come back later after @sec-hardware.
:::

It's highly recommended that you follow along and have a Julia session open (e.g. a REPL or a notebook) when first going through this chapter. See @sec-julia-basics if you haven't gotten that set up yet. Follow along with the examples as we go.

::: callout-tip
You can get some help in the REPL by typing a `?` followed by the symbol you want help with, for example:

``` julia-repl
 help?> sum
search: sum sum! summary cumsum cumsum! ...

  sum(f, itr; [init])


  Sum the results of calling function f on each element of itr.

... More text truncated...
```
:::

::: callout-caution
This introductory chapter is intended to provide a survey of the important concepts and building blocks, not to be a complete reference. For full details on available functions, more complete defintions, and a more complete tour of all language features, see the Manual at [docs.julialang.org](https://docs.julialang.org).
:::

## Assignment and Variables

One of the first things it will be convenient to understand is the concept of variables. In virtually every programming language, we can assign values to make our program more organized and meaningful to the human reader. In the following example, we assign values to intermediate symbols to benefit us humans as we convert (silly!) American distance units:

```{julia}
feet_per_yard = 3
yards_per_mile = 1760

feet = 3000
miles = feet / feet_per_yard / yards_per_mile
```

Beyond readability, variables are a form of **abstraction** which allows us to think beyond specific instances of data and numbers to a more general representation. For example, the last line in the prior code example is a very generic computation of a unit conversion relationship and `feet` could be any number and the expression remains a valid calculation.

We will return to this subject in more detail in @ref-assignment.

## Data Types

Data types are a way of categorizing information by intrinsic characteristics. We instinctively know that `13.24` is different than `"this set of words"` and types are how we will formalize this distinction. This is a key conceptual point, and mathematically it's like we have different sets of objects to perform specialized operations on. Beyond this set-like abstraction is implementation details related to computer hardware. You probably know that computers only natively "speak" in binary zeros and ones. Data types are a primary way that a computer can understand if it should interpret `01000010` as `B` or as `66`[^foundations-of-programming-2].

[^foundations-of-programming-2]: This binary representations correspond to `B` and `66` with the *ASCII character set* and 8-bit integer encodings respectely, discussed later in this chapter.

Each `0` or `1` within a computer is called a **bit** and eight bits in a row form a **byte** (such as `01000010`). This is where we get terms like "gigabytes" or "kilobits per second" as a measure of the quantity or rate of bits something can handle[^foundations-of-programming-3].

[^foundations-of-programming-3]: Some distinctions you may encounter: in short-form, "kb" means kilo*bits* while the upper-case "B" in "kB" means kilo*bytes*. Also confusingly, sometimes the "k" can be binary or decimal - because computers speak in binary, a binary "k" means 1024 (equal to 2\^10) instead of the usual decimal 1000. In most computer contexts, the binary (multiples of 1024) is more common.

### Numbers {#sec-number-types}

Numbers are usually grouped into two categories: **integers** and **floating-point**[^foundations-of-programming-4] numbers. Integers are like the mathematical set of integers while floating-point is a way of representing decimal numbers. Both have some limitations since computers can only natively represent a finite set of numbers due to the hardware (more on this in @sec-hardware). Here are three integers that are input into the **REPL** (Read-Eval-Print-Loop)[^foundations-of-programming-5] and the result is **printed** below the input:

[^foundations-of-programming-4]: The term floating point refers to the fact that the number's radix (decimal) point can "float" between the significant digits of the number.

[^foundations-of-programming-5]: That is, it *reads* the code input from the user, *evaluates* what code was given to it, *prints* the result of the input to the screen, and *loops* through the process again.

```{julia}
2
```

```{julia}
423
```

```{julia}
1929234
```

And three floating-point numbers:

```{julia}
0.2
```

```{julia}
-23.3421
```

```{julia}
14e3      # the same as 14,000.0
```

On most systems, `0.2` will be interpreted as a 64-bit floating point type called `Float64` in Julia since most architectures these days are 64-bit[^foundations-of-programming-6], while on a 32-bit system `0.2` would be interpreted as a `Float32`. Given that there are a finite amount of bits attempting to represent a continuous, infinite set of numbers means that some numbers are not able to be represented with perfect precision. For example, if we ask for `0.2`, the closest representations in 64 and 32 bit are:

[^foundations-of-programming-6]: This means that their central processing units (CPUs) use instructions that are 64 bits long.

-   `0.20000000298023223876953125` in 32-bit

-   `0.200000000000000011102230246251565404236316680908203125` in 64-bit

This leads to special considerations that computers take when performing calculations on floating point maths, some of which will be covered in more detail in @sec-hardware. For now, just note that floating point numbers have limited precision and even if we input `0.2`, your computations will use the above decimal representations even if it will print out a number with fewer digits shown:

```{julia}
x = 0.2 # <1>

big(x) # <2>
```

1.  Here, we **assign** the value `0.2` to a **variable** `x`. More on variables/assignments in @sec-assignment.
2.  `big(x)` is a arbitrary precision floating point number and by default prints the full precision that was embedded in our variable `x`, which was originally `Float64`.

::: callout-note
Note the difference in what printed between the last example and when we input `0.2` earlier in the chapter. The former had the same (not-exactly equal to $0.2$) *value*, but it printed an abbreviated set of digits as a nicety for the user, who usally doesn't want to look at floating point numbers with their full machine precision. The system has the full precision (`0.20...3125`) but is truncating the ouput.

In the last example, we've converted the normal `Float64` to a `BigFloat` which will not truncate the output when printing.
:::

Integers are similarly represented as 32 or 64 bits (with `Int32` and `Int64`) and are limited to exact precision:

-   -32,767 to 32,767 for `Int32`

-   -2,147,483,647 to 2,147,483,647 for `Int64`

Additional range in the positive direction if one chooses to use "unsigned", non-negative numbers (`UInt32` and `UInt64`). Unlike floating point numbers, the integers have a type `Int` which will use the system bit architecture by default (that is, `Int(30)` will create a 64 bit integer on 64-bit systems and 32-bit on 32-bit systems).

::: callout-tip
## Financial Modeling Pro-tip

Excel's numeric storage and routine is complex and not quite the same as most programming languages, which follow the Institute of Electrical and Electronics Engineer's standards (such as the IEEE 754 standard for double precision floating point numbers). Excel uses IEEE for the *computations* but results (and therefore the cells that comprise many calculations interim values) are stored with 15 significant digits of information. In some ways this is the worst of both worlds: having the sometimes unusual (but well-defined) behavior of floating point arithmetic *and* having additional modifications to various steps of a calculation. In general, you can assume that the programming language result (following the IEEE 754 standard) is a better result because there are aspects to the IEEE 754 defines techniques to minimize issues that arise in floating point math. Some of the issues (round-off or truncation) can be amplified instead of minimized with Excel.

In practice, this means that it can be difficult to exactly replicate a calculation in Excel in a progamming language and vice-versa. It's best to try to validate a programming model versus Excel model using very small unit calculations (e.g. a single step or iteration of a routine) instead of an all-in result. You may need to define some tolerance threshold for comparison of a value that is the result of a long chain of calculation.
:::

### Type Hierarchy

We can describe a *hierarchy* of types. Both `Float64` and `Int64` are examples of `Real` numbers (here, `Real` is an **abstract** Julia type which corresponds to the mathematical set of real numbers commonly denoted with $\mathbb{R}$ ). Both `Float64` and `Int32` are `Real` numbers, so why not just define all numbers as a `Real` type? Because for performant calculations, the computer must know in advance how many bits each number is represented with.

@fig-julia-numeric-types shows the type hiearchy for most built-in Julia number types.

```{mermaid}
%%| label: fig-julia-numeric-types
%%| fig-cap: "Numeric Type Hierarchy in Julia. Leafs of the tree are concrete types."
%%| fig-width: 6.5
graph TD
    Number --> Real
    Number --> Complex

    Real --> Integer
    Real --> AbstractFloat
    Real --> Rational
    Real --> Irrational

    Integer --> Signed
    Integer --> Unsigned

    Signed --> Int8
    Signed --> Int16
    Signed --> Int32
    Signed --> Int64
    Signed --> Int128
    Signed --> BigInt

    Unsigned --> UInt8
    Unsigned --> UInt16
    Unsigned --> UInt32
    Unsigned --> UInt64
    Unsigned --> UInt128

    AbstractFloat --> Float16
    AbstractFloat --> Float32
    AbstractFloat --> Float64
    AbstractFloat --> BigFloat
```

The integer and floating point types described in the prior section are known as **concrete** types because there are no possible sub types (child types). Further, a concrete type can be a **bit type** if the data type will always have the same number of bits in memory: a `Float32` will always be 32 bits in memory, for example. Contrast this with strings (described below) which can contain an arbitrary number of characters.

### Arrays

::: column-margin
[]{.juliadots} Julia has very powerful and friendly array types.
:::

Arrays are the most common way to represent a collection of similar data. For example, we can represent a set of integers as follows:

```{julia}
[1, 10, 300]
```

And a floating point array:

```{julia}
[0.2, 1.3, 300.0]
```

Note the above two arrays are different types of arrays. The first is `Vector{Int64}` and the second is `Vector{Float64}`. These are arrays of concrete types and so Julia will know that each element of an array is the same amount of bits which will enable more efficient computations. With the following set of mixed numbers, Julia will **promote** the integers to floating point since the integers can be accurately represented[^foundations-of-programming-7] in floating point.

[^foundations-of-programming-7]: Accurate only to a limited precision, as described in @sec-number-types.

```{julia}
[1, 1.3, 300.0, 21]
```

However, if we explicitly ask Julia to use a `Real`-typed array, the type is now `Vector{Real}`. Recall that `Real` is an abstract type. Having heterogeneous types within the array is conceptually fine, but in practice limits performance. Again, this will be covered in more detail in @sec-hardware.

In Julia, arrays can be multi-dimensional. Here are are two three-dimensional arrays with length three in each dimension:

```{julia}
rand(3, 3, 3)
```

```{julia}
[x + y + z for x in 1:3, y in 11:13, z in 21:23]
```

The above example demonstrates **array comprehension** syntax which is a convienient way to create arrays in Julia.

A two-dimensional array has the rows by semi-colons (`;`):

```{julia}
x = [1 2 3; 4 5 6]
```

::: callout-note
In Julia, a `Vector{Float64}` is simply a one-dimensional array of floating pointsand a `Matrix{Float64}` is a two-dimentional array. More precisely, they are **type aliases** of the more generic `Array{Float64,1}` and `Array{Float64,2}` names.
:::

#### Array indexing

Array elements are accessed with the integer position, starting at `1` for the first element[^foundations-of-programming-8] [^foundations-of-programming-9]:

[^foundations-of-programming-8]: Whether an index starts at `1` or `0` is sometimes debated. Zero-based indexing is natural in the context of low-level programming which deal with bits and positional *offsets* in computer memory. For higher level programming one-based indexing is more natural: in a set of data stored in an array, it is much more natural to reference the *first* (through $n^{th}$) datum instead of the *zeroth* (through $(n-1)^{th}$ datum.

[^foundations-of-programming-9]: Arrays in Julia can actually be indexed with an arbitrary starting point: see the package [OffsetArrays.jl](https://github.com/JuliaArrays/OffsetArrays.jl)

```{julia}
v = [10, 20, 30, 40, 50]
v[2]
```

We can also access a subset of the vector's contents by passing a range:

```{julia}
v[2:4]
```

And we can generically reference the array's contents, such as:

```{julia}
v[begin+1:end-1]
```

We can assign values into the array as well, as well as combine arrays and push new elements to the end:

```{julia}
v[2] = -1
push!(v, 5)
vcat(v, [1, 2, 3])
```

#### Array Alignment

When you have an MxN matrix (M rows, N columns), a choice must be made as to which elements are next to each other in memory. Typical math convention and fundamental computer linear algebra libraries (dating back decades!) are column major and Julia follows that legacy. **Column major** means that elements going down the rows of a column are stored next to each other in memory. This is important to know so that (1) you remember that vectors are treated like a column vector when working with arrays (a N element 1D vector is like a Nx1 matrix), and (2) when iterating through an array, it will be faster for the computer to access elements next to each other column-wise. A 10x10 matrix is actually stored in memory as 100 elements coming in order, one after another in single file.

This 3x4 matrix is stored with the elements of columns next to each other, which we can see with `vec`:

```{julia}
mat = [1 2 3; 4 5 6; 7 8 9]
```

```{julia}
vec(mat)
```

### Characters, Strings, and Symbols

Characters are represented in most programming languages as letters within quotation marks. In Julia, individual characters are represented using single quotes:

```{julia}
'a'
```

Letters and other characters present more difficulties than numbers to represent within a computer (think of how many languages and alphabets exist!), and it essentially only works because the world at large has agreed to a given representation. Originally **ASCII** (American Standard Code for Information Interchange) was used to represent just 95 of the most common English characters ("a" through "z", zero through nine, etc.). Now, UTF (Unicode Transformation Format) can encode more than a million characters and symbols from many human languages.

**Strings** are a collection[^foundations-of-programming-10] of characters, and can be created in Julia with double quotes:

[^foundations-of-programming-10]: Under the hood, strings are essentially a vector of characters but there are complexities with character encoding that don't allow a lossless conversion to individual characters of uniform bit length. This is for historical compatibility reasons and to avoid making most documents' file sizes larger than it needs to be.

```{julia}
"hello world"
```

It's easy to ascertain how 'normal' characters can be inserted into a string, but what about things like new lines or tabs? They are represented by their own characters but are normally not printed in computer output. However, those otherwise invisible characters do exist. For example, here we will use a **string literal** (indicated by the `"""` ) to tell Julia to interpret the string as given, including the invisible new line created by hitting return on the keyboard between the two words:

```{julia}
"""
hello
world
"""
```

The output above shows the `\n` character contained within the string.

**Symbols** are a way of representing an identifier which cannot be seen as a collection of individual characters. `:helloworld` is distinct from `"helloworld"` - you can kind of think of the former as an un-executed bit of code - if we were to execute it (with `eval(:helloworld)`), we would get an error `` UndefVarError: `a` not defined `` . Symbols can *look* like strings but do not behave like them. For now, it is best to not worry about symbols but it is an important aspect of Julia which allows the language to represent aspects of itself as data. This allows for powerful self-reference and self-modification of code but this is a more advanced topic generally out of scope of this book.

### Tuples

Tuples are a set of values that belong together and are denoted by a values inside parenthesis and separated by a comma. An example might be x-y coordinates in 2 dimensional space:

```{julia}
x = 3
y = 4
p1 = (x, y)
```

Tuple's values can be accessed like arrays:

```{julia}
p1[1]
```

Tuples fill a middle ground between scalar types and arrays in more ways that one:

-   Tuples have no problem having heterogeneous types in the different slots.

-   Tuples are **immutable**, meaning that you cannot overwrite the value in memory (an error will be thrown if we try to do `p[1] = 5`).

-   It's generally expected that within an array, you would be able to apply the same operation to all the elements (e.g. square each element) or do something like sum all of the elements together which isn't generally case for a tuple.

-   Tuples are generally stack allocated instead of being heap allocated like arrays[^foundations-of-programming-11], meaning that a lot of times they can be faster than arrays.

[^foundations-of-programming-11]: What this means will be explained in @sec-hardware .

#### Named Tuples

Named tuples provide a way to give each field within the tuple a specific name. For example, our x-y coordinate example above could become:

```{julia}
p2 = (x=3, y=4)
```

The benefit is that we can give more meaning to each field and access the values in a nicer way. Previously, we used `location[1]` to access the x-value, but with the new definition we can access it by name:

```{julia}
p2.x
```

### Parametric Types

We just saw how tuples can contain heterogeneous types of data inside a common container. Let's look at this a little bit closer by looking at the full type:

```{julia}
typeof(p1)
```

`location` is a `Tuple{Int64,Int64}` type, which means that its first and second elements are both `Int64`. Contrast this with:

```{julia}
typeof(("hello", 1.0))
```

These tuples are both of the form `Tuple{T,U}` where `T` and `U` are both types. Why does this matter? We and the compiler can distinguish between a `Tuple{Int64,Int64}` and a `Tuple{String,Float64}` which allows us to reason about things ("I can add the first element of tuple together only if both are numbers") and the compiler to optimize (sometimes it can know exactly how many bits in memory a tuple of a certain kind will need and be more efficient about memory use). Further, we will see how this can become a powerful force in writing appropriately abstracted code and more logically organize our entire program when we encounter "multiple dispatch" later on.

### Types for things not there

`nothing` represents that there's nothing to be returned - for example if there's no solution to an optimization problem or if a function just doesn't have any value to `return` (such as in the case with input/output like `println`).

`missing` is to represent something *should* be there but it's not, as is all too common in real-world data. Julia natively supports `missing` and three-value logic, which an an extension of the two-value boolean (true/false) logic, to handle missing logical values:

::: {#tbl-panel .column-page layout-ncol="3"}
| NOT (`!`)     | Value     |
|---------------|-----------|
| **`true`**    | `false`   |
| **`missing`** | `missing` |
| **`false`**   | `true`    |

: Not logic {#tbl-first}

| AND (`&`)     | `true`    | `missing` | `false` |
|---------------|-----------|-----------|---------|
| **`true`**    | `true`    | `missing` | `false` |
| **`missing`** | `missing` | `missing` | `false` |
| **`false`**   | `false`   | `false`   | `false` |

: And logic {#tbl-second}

| OR (`|`)      | `true` | `missing` | `false`   |
|---------------|--------|-----------|-----------|
| **`true`**    | `true` | `true`    | `true`    |
| **`missing`** | `true` | `missing` | `missing` |
| **`false`**   | `true` | `missing` | `false`   |

: Or Logic {#tbl-third}

Three value logic with `true`, `missing`, and `false`.
:::

::: callout-tip
`Missing` and `Nothing` are the *types* while `missing` and `nothing` are the values here. This is analagous to `Float64` being a type and `2.0` being a value.
:::

### Union Types

When two types may arise in a context, **union types** are a way to represent that. For example, if we have a data feed and we know that it will produce *either* a `Float64` *or* a `Missing` type then we can say that the value for this is `Union{Float64,Missing}`. This is much better for the compiler (and our performance!) than saying that the type of this is `Any`.

### Creating User Defined Types

We've talked about some built-in types but so much additional capabilities come from being able to define our own types. For example, taking the x-y-coordinate example from above, we could do the following instead of defining a tuple:

```{julia}
struct BasicPoint
    x::Int64
    y::Int64
end

p3 = BasicPoint(3, 4)
```

Fields are accessed the same way as named tuples:

```{julia}
p3.x, p3.y # <1>
```

1.  Note that here, Julia will return a tuple instead of a single value due to the comma separated expressions.

`structs` in Julia are immutable like tuples above.

But wait, didn't tuples let us mix types too via parametric types? Yes, and we can do the same with our type!

```{julia}
struct Point{T}
    x::T
    y::T
end
```

Line 1 The `{T}` after the type's name allows for different `Point`s to be created depending on what the type of the underlying `x` and `y` is.

Here's two new points which now have different types:

```{julia}
p4 = Point(1, 4)
p5 = Point(2.0, 3.0)

p4, p5
```

Note that the types are not equal because they have different type parameters!

```{julia}
typeof(p4), typeof(p5), typeof(p4) == typeof(p5)
```

But both are now subtypes of `PPoint2D`. The expression `X isa Y` is `true` when `X` is a (sub)type of `Y`:

```{julia}
p4 isa Point, p5 isa Point
```

Note though, that the `x` and `y` are both of the same type in each `PPoint2D` that we created. If instead we wanted to allow the coordinates to be of different types, then we could have defined `PPoint2D` as follows:

``` julia
struct Point{T,U}
    x::T
    y::U
end
```

::: callout-note
Can we define the `struct`s above without indicating a (parametric) type? Yes!

``` julia
struct Point
    x # no type here!
    y # no type declared here either!
end
```

But! `x` and `y` will both be allowed to be `Any`, which is the fallback type where Julia says that it doesn't know any more about the type until runtime (the time at which our program encounters the data when running). This means that the compiler (and us!) can't reason about or optimize the code as effectively as when the types are explicit or parametric. This is an example of how Julia can provide a nice learning curve - don't worry about the types until you start to get more sophicistited about the program design or need to extract more performance from the code.
:::

The above `struct`s that we have defined are examples of **concrete types** types which hold data. **Abstract types** don't directly hold data themselves but are used to define a hiearchy of types which we will later exploit (@sec-patterns-abstractions) to implement custom behavior depending on what type our data is.

Here's an example of (1) defining a set of related types that sits above our `Point2D`:

```{julia}
#| output: false
abstract type Coordinate end
abstract type CartesianCoordinate <: Coordinate end
abstract type PolarCoordinate <: Coordinate end

struct Point2D{T} <: CartesianCoordinate
    x::T
    y::T
end

struct Point3D{T} <: CartesianCoordinate
    x::T
    y::T
    z::T
end

struct Polar2D{T} <: PolarCoordinate
    r::T
    θ::T
end
```

::: callout-tip
## Unicode Characters

Julia has wonderful Unicode support, meaning that it's not a problem to include characters like `θ`. The character can be typed in Julia editors by entering `\theta` and then pressing the TAB key on the keyboard.

Unicode is helpful for following conventions that you may be used to in math. For example, the math formula $\text{circumference}(r) = 2 \times r \times \pi$ can be written in Julia with `circumference(r) = 2 * r * π`.

The name for the characters follows the same for LaTeX, so you can search the internet for,e.g. "theta LaTeX" to find the appropriate name. Furhter, you can use the REPL help mode to find out how to enter a character if you can copy and paste it from somewhere:

``` julia-repl
help?> θ
"θ" can be typed by \theta<tab>
```
:::

### Mutable structs

It is possible to define `struct`s where the data can be modified - such a data field is said to be **mutable** because it can be changed or mutated. Here's an example of what it would look like if we made `Point2D` mutable:

``` julia
mutable struct Point2D{T}
    x::T
    y::T
end
```

You may find that this more naturally represents what you are trying to do. However, recall that an advantage of an immutable datatype is that costly memory doesn't necessarily have to be allocated for it. So you may think that you're being more efficient by re-using the same object... but it may not actually be faster. Again, more will be revealed in @sec-hardware.

::: callout-tip
## Financial Modeling Pro-tip

Generally you should default to using immutable types and consider only moving to `mutable` types in specific circumstances. You'll see some examples in the applications later in the book.
:::

### Constructors

**Constructors** are functions that return a data type (functions will be covered more generally later in the chapter). When we declare a `struct`, an implicit function is defined that takes a tuple of arguments and returns the data type that was declared. In the following example, after we define `MyType` the `struct`, Julia creates a function (also called `MyType`) which takes two arguments and will return the datatype `MyType`:

```{julia}
struct MyDate
    year::Int
    month::Int
    year::Int
end

methods(MyDate)
```

Implicit constructors are nice in that you don't have to define a default method and the language does it for you. Sometimes there's reasons to want to control how an object is created, either for convenience or to enforce certain restrictions.

We can use an inner constructor (i.e. inside the `struct` block) to enforce restrictions:\

``` julia
struct MyDate
    year::Int
    month::Int
    year::Int

    function MyDate(y,m,d)
        if ~(m in 1:12)
            error("month is not between 1 and 12")
        else if ~(d in 1:31)
            error("day is not between 1 and 31")
        else
            return new(y,m,d)
        end

    end
                
end
```

And outer constructors are simply functions defined that have the same name as the data type , but are not defined inside the `struct` block. Extending the `MyDate` example, say we want to provide a default constructor for if no day is given such that the date returns the 1st of the month:

``` julia
function MyDate(y,m)
    return MyDate(y,m,1)
end
```

## Expressions and Control Flow

Having already seen some more illustrative examples above, we can zoom in onto smaller pieces called **expressions** which are effectively the basic block of code that gets evaluated. Here is an expression that adds two integers together that evaluate to a new integer (`3` in this case):

```{julia}
1 + 2
```

### Compound Expression

There's two kinds of blocks where we can ensure that subexpressions get evaluated in order and return the last expression as the overall return value: `begin` and `let` blocks.

```{julia}
c = begin
    a = 3
    b = 4
    a + b
end

a, b, c
```

The variables inside the `begin` block are evaluated in the same scope as `c` and therefore have the assigned values when we call `a` and `b` in the last line. Contrast that with the `let` block below, where `d` and `e` are not available when we try to get the value of `f`. This is because `let` creates a new inner scope that's not available in `f`'s scope. More on scope later in the chapter.

```{julia}

f = let
    d = 1
    e = 2
    d + e
end
f
```

```{julia}
#| error: true
d
```

### Conditional Expressions

**Conditionals** are expressions that evaluate to a **boolean** `true` or `false`. This is the beginning of really being able to assemble complex logic to perform useful work. Here are a handful expressions that would evaluate to `true`:

```         
1 > 0
1 == 1 # check for equality
Float64 isa Rational
(5 > 0) & (-1 < 2) # "and" expression
(5 > 0) | (-1 > 2) # "or" expression
1 != 2
```

::: callout-note
In Julia, the booleans have an integer equality: `true` is equal to `1` (`true == 1`) and `false` is equal to `0` (`false == 0`). However:

-   `true != 5`. Only `1` is equal to true (in some languages, any non-zero number is "truthy").
-   `true` is not egal to `1` (egal is defined later in this chapter).
:::

Conditionals can be used to assemble different logical paths for the program to follow and the general pattern is an `if` block:

``` julia
if condition
    # do one thing
elseif condition
    # do something else
else
    # do something if none of the 
    # other conditions are met
end
```

A complete example:

```{julia}
function buy_or_sell(my_value, market_price)
    if my_value > market_price
        "buy more"
    elseif my_value < market_price
        "sell"
    else
        "hold"
    end
end

buy_or_sell(10, 15), buy_or_sell(15, 10), buy_or_sell(10, 10)

```

#### Equality

The "Ship of Theseus[^foundations-of-programming-12]" problem is an example of how equality can be philosophically complex concept. In computer science we have the advantage that while we may not be able to resolve what's the "right" type of equality, we can be more precise about it.

[^foundations-of-programming-12]: The Ship of Theseus problem specifically refers to a legendary ancient Greek ship, owned by the hero Theseus. The paradox arises from the scenario where, over time, each wooden part of the ship is replaced with identical materials, leading to the question of whether the fully restored ship is still the same ship as the original. The Ship of Theseus problem is a thought experiment in philosophy that explores the nature of identity and change. It questions whether an object that has had all of its components replaced remains fundamentally the same object.

Here is an example for which we can see the difference between two types of equality:

-   **Egal** equality is when a program could not distinguish between two objects at all

-   **Equal** equality is when the values of two objects are the same

If two things are egal, then they are also equal.

In the following example, `s` and `t` are equal but not egal:

```{julia}
s = [1, 2, 3]
t = [1, 2, 3]
s == t, s === t
```

One way to think about this is that while the values are equal, there is a way that one of the arrays could be made not equal to the other:

```{julia}
t[2] = 5
t
```

Now `t` is no longer equal to `s`:

```{julia}
s == t
```

Recall that arrays are able to be modified, but other types like tuples are immutable. Immutable types with the same value are egal because there is no way for us to make them different:

```{julia}
(2, 4) === (2, 4)
```

Using this terminology, we could now interpret the "Ship of Theseus" as that his ship is "equal" but not "egal".

### Assignment and Variables {#sec-assignment}

When we say `x = 2` we are **assigning** the integer value of `2` to the variable `x`. This is an expression that lets us bind a something to a variable so that it can be referenced more concisely or in different parts of our code. When we re-assign the variable we are not mutating the value: `x = 3` does not change the `2`.

When we have a mutable object (e.g. an `Array` or a `mutable struct`), we can mutate the value inside the referenced container. For example:

```{julia}
x = [1, 2, 3] # <1>
x[1] = 5 # <2>
x
```

1.  `x` refers to the array which currently contains the elements `1`, `2`, and `3`.
2.  We re-assign the first element of the array to be the value `5` instead of `1`

In the above example, `x` has not been reassigned. It is possible for two variables to refer to the same object:

```{julia}
x = [1,2,3]
y = x # <1>
x[1] = 6
y
```

1.  `y` refers to the *same* underlying array as `x`

### Loops

**Loops** are ways for the program to move through a program and repeat expressions while we want it to. There are two primary loops: `for` and `while`.

**`for` loops** are loops that iterate over a defined range or set of values. Let's assume that we have the array `v = [6,7,8]`. Here are multiple examples of using a `for` loop in order to print each value to output (`println`):

``` julia
# use fixed indices
for i in 1:3
    println(v[i])
end
```

``` julia
# use indices the of the array
for i in eachindex(v)
    println(v[i])
end
```

``` julia
# use the elements of the array
for x in v
    println(x)
end
```

``` julia
# use the elements of the array
for x ∈ v          # ∈ is typed \in<tab>
    println(x)
end
```

**`while` loops** will run repeatedly until an expression is false. Here's some examples of printing each value of `v` again:

``` julia
# index the array
i = 1
while i <= length(v) 
    println(v[i])
    global i += 1 #<1>
end
```

1.  `global` is used to incrment `i` by 1. `i` is defined outside the scope of the `while` loop (see @sec-scope).

``` julia
# index the array
i = 1
while true
    println(v[i])
    if i >= length(v)
        break # <1>
    end
    global i += 1 
end
```

1.  `break` is used to terminate the loop manually, since the condition that follows the `while` will never be false.

### Performance of loops

Loops are highly performant in Julia and often the fastest way to accomplish things. Those coming from Python or R may have developed a habit to avoid writing loops. *Fear the for loop not!*

## Functions

Functions are a set of expressions that take inputs and return specified outputs.

### Special Operators

Operators are the glue of expressions which combine values. We've already seen quite a few, but let's develop a little bit of terminology for these functions.

**Unary operators** are operators which only take a single argument. Examples include the `!` which negates a boolean value or `-` which negates a number:

```{julia}
!true, -5
```

**Binary operators** take two arguments and are some of the most common functions we encounter, such as `+` or `-` or `>`:

```{julia}
1 + 2, 1 - 2, 1 > 2
```

The above unary and binary operators are special kinds of functions which don't require the use of parenthesis. However, they can be written with parathesis for greater clarity:

```{julia}
!(true), -(5), +(1,2), -(1,2)
```

In Julia, we distinguish between **functions** which define behavior that maps a set of inputs to outputs. But a single function can adapt its behavior to the arguments themselves. We have just seen the function `-` be used in two different ways: negation and subtraction depending on whether it had one or two arguments given to it. In this way there is a conceptual hierarchy of functions that complements the hierarchy we have discussed in relation to types:

-   `-` is the overall function
-   `-(x)` is a unary function which negates its values, `-(x,y)` subtracts `y` from `x`
-   Specific methods are then created for each combination of concrete types: `-(x::Float64)` is a different method than `-(x::Int)`

**Methods** are specific compiled versions of the function for specific types. This is important because at a hardware level, operations for different types (e.g. integers versus floating point) differ considerably. By optimizing for the speicifc types Julia is able to achieve nearly ideal performance without the same sacrifices of other dynamic languages. We will develop more with respect to methods when we talk about dispatch in @sec-patterns-abstractions.

### General Functions

Funcitons more generally are defined like so:

```{julia}
function distance(point) # <1>
    return sqrt(point.x^2 + point.y^2) # <2>
end 
```

1.  A `function` block is declared with the name `distance` which takes a single argumemnt called `point`
2.  We compute the distance formla for a point with x and y coordinates. The `return` value make explicit what value the function will output.

::: callout-note
An alternate, simpler function syntax for `distance` would be:

``` julia
distance(point) = sqrt(point.x^2 + point.y^2)
```
:::

However, we might at this point note a flaw in our function's defintion if we think about the various `Coordinate`s we defined earler: our definition would currently only work for `Point2D`. For example, if we try a `Point3D` we will get the wrong answer:

```{julia}
distance(Point3D(1, 1, 1,))
```

The above value should be $\sqrt(3)$, or approximately $1.73205$. What we need to do is define a refined distance for each type, which we'll call `dist` to distinguish from the earlier definition. We'll also use the opportunity to introduce the syntax for documenting functions in Julia, which is simply to put a string (`"..."`) or string literal (`"""..."""`) right above the defintion.

```{julia}
"""
    dist(point)

The euclidean distance of a point from the origin.
"""
dist(p::Point2D) = sqrt(p.x^2 + p.y^2)
dist(p::Point3D) = sqrt(p.x^2 + p.y^2 + p.z^2)
dist(p::Polar2D) = p.r
```

Now our result will be correct:

```{julia}
dist(Point3D(1, 1, 1,))
```

In the next chapter we'll develop some more tools, which would, for example let us define the function `dist(p::CartesianCoordinate)` and generically define the distance for all of `CartesianCoordinate`'s subtypes.

::: callout-caution
## Defining Methods for Parametric Types

We learned that `Float64 <: Real` in the type hierarchy. However, note that `Tuple{Float64}` is not a subtype of `Tuple{Real}`. This is called being **invariant** in type theory... but for our purposes this just practically means that when we define a method we need to specify that we want it to apply to all subtypes.

For example, `myfunction(x::Tuple{Real})` would *not* be called if x was a `Tuple{Float64}` because it's not a subtype of `Tuple{Real}`. To act the way we want, would define the method with the signature of `myfunction(Tuple{<:Real})` or `myfunction{Tuple{T}} where {T<:Real}`.
:::

### Keyword Arguments

**Keyword arguments** are arguments that are passed to a function but do not use *position* to pass data to functions but instead used named arguments. In the following example, `filepath` is a **positional argument** while the two arguments after the semicolon (`;`) are keyword arguments.

``` julia
function read_data(filepath; normalize_names, has_header_row)
    # ... function would be defined here
end
```

The function would need to be called and have the two keyword arguments specified:

``` julia
read_data("results.csv"; normalizenames=true, hasheaderrow=false)
```

### Default Arguments

We are able to define default arguments for both positional and keyword arguments via an assignment expression in the function signature. For example, we can make it so that the user need not specify all the options for each call. Modifying the prior example so that typical CSVs work with less customization from the user:

``` julia
function read_data(filepath;
    normalizenames = true,
    hasheader = false
)
```

This is a simplified example, but if you look at the documentation for most data import packages you'll see a lot of functionality defined via keyword arguments which have sensible defaults so that most of the the time you need not worry about modifying them.

### Anonymous Functions

**Anonymous functions** are functions that have no name and are used in contexts where the name does not matter. The syntax is `x -> ...expression with x...`. As an example, say that we want to create a vector from another where each element is squared. `map` applies a function to each member of a given collection:

```{julia}
v = [4, 1, 5]
map(x -> x^2, v)  # <1>
```

1.  The `x -> x^2` is the anonymous function in this example.

They are often used when constructing something from another value, or defining a function within optimization or solving routines.

### Passing by Sharing

Arguments to a function in Julia are \*passed-by-sharing\*\* which means that an outside variable can be mutated from within a function. We can modify the array in the outer scope (scope discussed later in this chapter) from within the function. In this example, we modify the array that is assigned to `v` by doubling each element:

```{julia}
v = [1, 2, 3]

function double!(v)
    for i in eachindex(v)
        v[1] = 2 * v[i]
    end
end

double!(v)

v
```

::: callout-tip
Convention in Julia is that a function that modifies it's arguments has a `!` in it's name and we follow this convention in `double!` above. Another example would be the built-in function `sort!` which will sort an array in-place without allocating a new array to store the sorted values.
:::

We won't discuss all potential ways that programming languages can behave in this regard, but an alternative that one may have seen before (e.g. in Matlab) is pass-by-value where a modification to an argument only modifies the value within the scope. Here's how to replicate that in Julia by `copy`ing the value before handing it to a function. This time, v is not modified because we only passed a copy of the array and not the array itself:

```{julia}
v = [1, 2, 3]
double!(copy(v))
v
```

### Broadcasting

Looking at the prior definition of `dist`, what if we wanted to compute the squared distance from the origin for a set of points? If those points are stored in an array, we can **broadcast** functions to all members of a collection at the same time. This is accomplished using the **dot-syntax** as follows:

```{julia}
points = [Point2D(1, 2), Point2D(3, 4), Point2D(6, 7)]
dist.(points) .^ 2
```

Let's unpack that a bit more:

1.  The `.` in `dist.(points)` tells Julia to apply the function `dist` to each element in `points`.
2.  The `.` in `.^` tells Julia to square each values as well

Why broadcasting is useful:

1.  Without needing any redefinition of functions we were able to transform the function `dist` and exponentiation (`^`) to work on a collection of data. This means that we can keep our code simpler and easier to reason about (operating on individual things is easier than adding logic to handle collections of things).
2.  When multiple broadcasted operations are joined together, Julia can **fuse** the operations so that each operation is performed at the same time instead of each step sequentially. That is, if the operation were not fused, the computer would first calculate `dist` for each point, and then apply the square on the collection of distances. When it's fused, the operations can happen at the same time without creating an interim set of values.

::: callout-note
For readers coming from numpy-flavored Python or R, broadcasting is a way that can feel familiar to the array-oriented behavior of those two languages. Once you feel comfortable with Julia in general, you may find yourself relaxing and relying less on array-oriented design and instead picking whichever iteration paradigm feels most natural for the problem at hand: loops or broadcasting over arrays.
:::

#### Broadcasting Rules

What happens if one of the collections is not the same size as the others? When broadcasting, singleton dimensions (i.e. the 1 in 1xN, "1-by-N", dimensions) will be expanded automatically when it makes sense. For example, if you have a single element and a one dimensional array, the single element will be expanded in the function call without using any additional memory (if that dimension matches one of the dimensions of the other array).

The rules with an MxN and a PxQ array:

-   either (M and P) or (N and Q) need to be the same, *and*
-   one of the non-matching dimensions needs to be 1

Some examples might clarify. This 1x1 element is being combined with a 4x1, so there is a compatible dimension (N and Q match, M is 1):

```{julia}
2 .^ [0, 1, 2, 3]
```

Here, this 1x3 works with the 2x3 (N and Q match, M is 1)

```{julia}
[1 2 3] .+ [1 2 3; 4 5 6]
```

This 3x1 isn't compatible with this 2x3 array (neither M and P nor N and Q match)

```{julia}
#| error: true
[1, 2, 3] .+ [1 2 3; 4 5 6]
```

This 2x4 isn't compatible with the 2x3 (M and P match, but N nor Q is 1):

```{julia}
#| error: true
[1 2; 3 4] .+ [1 2 3; 4 5 6]
```

#### Not Broadcasting

What if you do not want the array to be used element-wise when broadcasting? Then you can wrap the array in a `Ref`, which is used in broadcasting to make the array be treated like a scalar. In the example below, `in(needle,haystack)` searches a collection (`haystack`) for an item (`needle`) and returns `true` or `false` if the item is in the collection:

```{julia}
in(4, [1 2 3; 4 5 6])
```

What if we had an array of things ("needles") that we wanted to search for? By default, broadcasting would effectively split the array up into collections of individual elements to search:

```{julia}
in.([1, 9], [1 2 3; 4 5 6])
```

Effectively, the result above is the result of this broadcasted result:

``` julia
in(1, [1,2,3]) # the first row of the above result
in(9, [4,5,6])
```

If we were expecting Julia to return `[1,0]` (that the first needle is in the haystack but the second needle is not), then we need to tell Julia not to broadcast along the second array with `Ref`:

```{julia}
in.([1, 9], Ref([1 2 3; 4 5 6]))
```

### First Class Nature

Functions in many languages including Julia are **first class** which means that functions can be assigned and moved around like data variables.

In this example, we have a general approach to calculate the error of a modeled result compared to a known truth. In this context, there are different ways to measure error of the modeled result and we can simplify the implementation of `loss` by keeping the different kinds of error defined separately. Then, we can assign a function to a variable and use it as an argument to another function:

```{julia}
function square_error(guess, correct)
    (correct - guess)^2
end

function abs_error(guess, correct)
    abs(correct - guess)
end

# obs meaning "observations"
function loss(modeled_obs,
    actual_obs,
    loss_function # <1>
)
    sum(
        loss_function.(modeled_obs, actual_obs)
    )
end

let # <2>
    a = loss([1, 5, 11], [1, 4, 9], square_error) # <3>
    b = loss([1, 5, 11], [1, 4, 9], abs_error)  # <3>
    a, b
end
```

1.  `loss_function` is a variable that will refer to a function instead of data.
2.  Using a `let` block here is good practice to not have temporary variables `a` and `b` scattered around our workspace.
3.  Using a function as an argument to another function is an example of functions being treated as "first class".

## Scope {#sec-scope}

In projects of even modest complexity, it can be challenging to come up with unique identifiers for different functions or variables. **Scope** refers to the bounds for which an identifier is available. We will often talk about the **local scope** that's inside some expression that creates a narrowly defined scope (such as a `function` or `let` or `module` block) or the **global scope** which is the top level scope that contains everything else inside of it. Here are a few examples to demonstrate scope.

```{julia}
i = 1 #<1>
let #<2> 
    j = 3 #<3>
    i + j
end
```

1.  `i` is defined in the global scope and would be available to other inner scopes.
2.  The `let ... end` block creates a local scope which inherits the defined global scope definitions.
3.  `j` is only defined in the local scope created by the `let` block.

In fact, if we try to use `j` outside of the scope defined above we will get an error:

```{julia}
#| error: true
j
```

Here is an example with functions:

```{julia}
x = 2
base = 10
foo() = base^x #<1>
foo(x) = base^x #<2>
foo(x, base) = base^x #<3>

foo(), foo(4), foo(4, 4)
```

1.  Both `base` and `x` are inherited from the global scope.
2.  `x` is based on the local scope from the function's arguments and `base` is inherited from the global scope.
3.  Both `base` and `x` are defined in the local scope via the function's arguments.

In Julia, it's always best to explicitly pass arguments to functions rather than relying on them coming from an inherited scope. This is more straight-forward and easier to reason about and it also allows Julia to optimize the function to run faster because all relevant variables coming from outside the function are defined at the function's entry point (the arguments).

### Modules and Namespaces

**Modules** are ways to encapsulate related functionality together. Another benefit is that the variables inside the module don't "pollute" the **namespace** of your current scope. Here's an example:

```{julia}
module Shape #<1>

    struct Triangle{T}
        base::T
        height::T
    end

    function area(t::Triangle) # <2>
        return 1/2 * t.base * t.height
    end
end

t = Shape.Triangle(4,2) # <3>
area = Shape.area(t)  # <4>
```

1.  `module` defines an encapsulated block of code which is anchored to the namespace `Shape`
2.  Here, `area` a *function* defined within the `Shape` module.
3.  Outside of `Shape` module, we can access the definitions inside via the `Module.identifier` syntax.
4.  Here, `area` is a *variable* in our global scope that *does not* conflict with the `area` defined within the `Shape` module. If `Shape.area` were not within a module then when we said `area = ...` we would have reassigned `area` to no longer refer to the function and instead would refer to the area of our triangle.

::: callout-note
Summarizing related terminology:

-   A **module** is a block of code such as `module MySimulation ... end`

-   A **package** is a module that has a specific set of files and associated metadata. Essentially, it's a module with a `Project.toml` file that has a name and unique identifier listed, and a file in a `src/` directory called `MySimulation.jl`

    -   **Library** is just another name for a package, and the most common context this comes up is when talking about the packages that are bundled with Julia itself called the **standard library** (`stdlib`).
:::