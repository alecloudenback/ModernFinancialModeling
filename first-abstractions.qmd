# First Abstractions {#sec-first-abstractions}

> QUOTE NEEDED

## In this section

Demonstrate different approaches to a problem which gradually introduce more re-usable or general techniques. These techniques will allow for constructing sophisticated models while maintaining coniststency and simplicity. Imperative programming, functional programming, and using types to simplify program logic.

## Introduction

This chatpter will center around a simple task: calculate the present value of a portfolio of two fixed, copoun-paying bonds under two different interest rate environments. The focus will be on describing different approaches to this problem, not be adding complexity to the problem (e.g. no getting into credit spreads, settlement timing, etc.).

```{julia}
cf_bond = [10, 10, 10, 10, 110];
rate = [0.05, 0.06, 0.05, 0.04, 0.05]; # <1>
```

1.  The rates given are the one year rate for time zero, time one, etc.

The other bond and set of rates is described later in the chapter.

Mathematically, the problem is to determine the $\text{Present Value}$, where:

$$
\text{Present Value} = \sum{\text{Cashflow}_t \times \text{Discount Factor}_t}
$$

Where

$$
\text{Discount Factor}_t = \prod^t{\frac{1}{1+\text{Discount Rate}_i}}
$$

We will repeatedly solve the same problem before extending it to more examples. It may feel repetitive but the focus here is not the problem, but rather the variations between the different approaches.

## Imperative Style

One of the most familiar styles of programming is called **imperative** (or **procedural**), where we provide step-by-step commands are provided to the computer. The programmer defines the data involved and how that data moves through the program one step at a time. It commonly uses loops to perform tasks repeatedly or across a set of data. The program's **state** (assigment and logic of the program's variables) is defined and managed by the programmer explicitly.

Here's an imperative style of calculating the present value of the bond.

```{julia}
let
    #<1>
    pv = 0.0
    discount = 1.0

    for i in 1:length(cf_bond) #<2>
        discount = discount / (1 + rate[i])
        pv = pv + discount * cf_bond[i] # <3>
    end
    pv
end
```

1.  Declare variables to keep track of the discount rate and running total for value
2.  Loop the length of the cashflow vector.
3.  At each step of the loop, look up (via index `i`) update the discount factor to account for the prevailing rate and add the discounted cashflow to the running total present value.

This style is simple, digestable, and clear. If we were performing the calculation by hand, it would likely follow a pattern very similar to this. Look up the first cashflow and discount rate, compute a discount factor, and subtotal the value. Repeat for the next set of values.

### Iterators

Note that in the prior code example we defined an index variable `i` and had to manually define the range over which it would operate (`1` through the `length` of the bond's cashflow vector). A couple of reasons this could be sub-optimal:

1.  We are making the *assumption* that the indices of the vectors start with one, when in reality Julia arrays *can* be defined to start at `0` or another arbitrary index.
2.  We manually perform the lookup of the values within each iteration.

We can solve the first one (partially) by letting Julia return an iterable set of values corresponding to the indices of the `cf_bond` vector. Tihs is an example of an **iterator** which is an object upon which we can repeatedly ask for the next value until it tells us to stop.

By using `eachindex` we can get the indices of the vector since Julia already knows what they are:

```{julia}
eachindex(cf_bond)
```

::: callout-note
## Lazy Programming

The result, `{julia} eachindex(cf_bond)` is a **lazy** object which represents a collection that does not get fully instantiated until asked to (which may not actually be necessary). Many (most?) iterators are lazy but we can interact with them without fully instantiating the data that they represent. For example, we could find the largest index:

```{julia}
maximum(eachindex(cf_bond))
```

The point is if we have an object that *represents* a set, we need not actually enumerate each element of the set to interact with it.

We can fully instantiate an iterator with `collect`

```{julia}
collect(eachindex(cf_bond))
```

Laziness is generally a good thing in programming because sometimes it can be computationally or memory expensive to fully instantiate the collection of interest.
:::

And when used in context:

```{julia}
let
    pv = 0.0
    discount = 1.0

    for i in eachindex(cf_bond)
        discount = discount / (1 + rate[i])
        pv = pv + discount * cf_bond[i]
    end
    pv
end
```

Here Julia gave us the index associated with the bond cashflows, but we are still looking up the values (why not just ask for the values instead of their index?) as well as assuming that the indices are the same for the discount rates.

We can get the value and the associated index with `enumerate`:

```{julia}
collect(enumerate(cf_bond))
```

This would allow us to skip the step of needing to look up the bond's cashflows. However, we can go even further by just asking for value associated with both collections. With `zip` (named because it's sort of like zipping up two collections together), we get an iterator that provides the values of the underlying collections:

```{julia}
collect(zip(cf_bond, rate))
```

This provides the simplest implementation of the imperative approaches:

```{julia}
let
    pv = 0.0
    discount = 1.0

    for (cf, r) in zip(cf_bond, rate)
        discount = discount / (1 + r)
        pv = pv + discount * cf
    end
    pv
end
```

The primary downsides to this approach are:

1.  Needing to keep track of state is fine in simple cases, but can quickly become difficult to reason about and error prone as the number and complexity of variables grows.
2.  Program flow is explicitly stated, leaving fewer places that the compiler can automatically optimize or parallelize.

Note that it's when state is `mutable` that a program tends to be more complex.

## Functional Techniques and Terminology

**Functional** programming is a paradigm which attempts to minimize state via composing functions together.

@tbl-funcional-methods introduces a set of core functional methods to familiarize yourself with. Note that anonymous functions (#sec-anonymous-functions) are used frequently to define intermediary steps.

+--------------------------+---------------------------------------------------------------------------------------------------------------------------------------+---------------+
| Function                 | Desciption                                                                                                                            | Example       |
+==========================+=======================================================================================================================================+===============+
| `map(f,v)`               | Apply function `f` to each element of the collection `v`.                                                                             | ``` julia     |
|                          |                                                                                                                                       | map(          |
|                          |                                                                                                                                       |     x->x^2,   |
|                          |                                                                                                                                       |     [1,3,5]   |
|                          |                                                                                                                                       | ) # [1,9,25]  |
|                          |                                                                                                                                       | ```           |
+--------------------------+---------------------------------------------------------------------------------------------------------------------------------------+---------------+
| `reduce(op,v)`           | Apply binary `op` to pairs of values, reducing the dimension of the collection `v`.\                                                  | ``` julia     |
|                          | \                                                                                                                                     | reduce(       |
|                          | Has a couple of important, optional keyword arguments to note (which also apply to other variants of `reduce` below):                 |     *,        |
|                          |                                                                                                                                       |     [1,3,5]   |
|                          | -   `init` defines the identity element (e.g. the initial value of `+` and `*` is `0` and `1` respectively)                           | ) # 15        |
|                          | -   `dims` defines which dimension to reduce across (if the dimension of `v` is more than one).                                       | ```           |
+--------------------------+---------------------------------------------------------------------------------------------------------------------------------------+---------------+
| `mapreduce(op,f,v)`      | Maps `f` over collection `v` and returns a reduced result using `op`.                                                                 | ``` julia     |
|                          |                                                                                                                                       | mapreduce(    |
|                          |                                                                                                                                       |     *,        |
|                          |                                                                                                                                       |     x->x^2,   |
|                          |                                                                                                                                       |     [1,3,5]   |
|                          |                                                                                                                                       | ) # 35        |
|                          |                                                                                                                                       | ```           |
+--------------------------+---------------------------------------------------------------------------------------------------------------------------------------+---------------+
| `foldl(op,v)foldr(op,v)` | Like `reduce`, but applies `op` from left to right (`foldl`) or right to left (`foldr`). Also has `mapfoldl` and `mapfoldr` versions. | ``` julia     |
|                          |                                                                                                                                       | foldl(        |
|                          |                                                                                                                                       |     *,        |
|                          |                                                                                                                                       |     [1,3,5]   |
|                          |                                                                                                                                       | ) # 15        |
|                          |                                                                                                                                       | ```           |
+--------------------------+---------------------------------------------------------------------------------------------------------------------------------------+---------------+
| `accumulate(op,v)`       | Apply `op` along `v` , creating a vector with the cumulative result.                                                                  | ``` julia     |
|                          |                                                                                                                                       | accumulate(   |
|                          |                                                                                                                                       |     +,        |
|                          |                                                                                                                                       |     [1,3,5]   |
|                          |                                                                                                                                       | ) # [1, 4, 9] |
|                          |                                                                                                                                       | ```           |
+--------------------------+---------------------------------------------------------------------------------------------------------------------------------------+---------------+
| `filter(f,v)`            | Apply `f` along `v` and return a copy of `v` with elements where `f` is true                                                          | ``` julia     |
|                          |                                                                                                                                       | filter(       |
|                          |                                                                                                                                       |     >=(3),    |
|                          |                                                                                                                                       |     [1,3,5]   |
|                          |                                                                                                                                       | ) # [3, 5]    |
|                          |                                                                                                                                       | ```           |
+--------------------------+---------------------------------------------------------------------------------------------------------------------------------------+---------------+

: caption TBD {#tbl-funcional-methods}

This paradigm is very powerful in a few ways:

1.  It provides a language for talking about what a computation is doing. Instead of "looping over a collection called `portfolio` and calling a `value` function" we can more concisely refer to this as `mapreduce(valuem,portfolio)`.
2.  Often times you are forced to think about the design of the program more deeply, recognizing the core calculations and data used within the model.
3.  The compiler is free to apply more optimizations. For example, with `reduce`, the compiler could drive the calculation in any order since the operation is associative.
4.  The lack of mutable state

Let's build a version of the present value calculation using the functional building blocks described above.

First, to show how we could calculate the discount factor:

```{julia}
accumulate(
    (discount_factor, cur_rate) -> discount_factor / (1 + cur_rate), #<1>
    rate; # <2>
    init=1 # <3>
)
```

1.  An anonymous function which takes the accumulated discount factor and next value and computes the updated discount factor.
2.  The collection of rates that we are operating on.
3.  We define what the initial value should be (otherwise the first value of `rate` will be the initially returned value).

Compared to the imperative version, we have still defined a function (albeit an anonymous one) that defines a routine that calculates a discount factor. In this case though, the intermediate variables `cur_rate` and `discount_factor` are local to the anonymous function and can't get mixed up if this code was running simultaneously in different parts of our program.

::: callout-tip
At the risk of sounding obvious, an easy way to make the program more "functional" is to simply use more functions. Do this one thing and it will improve the model's organization, maintainability, and reduce bugs!\
\
Take the example from earlier:

``` julia
pv = 0.0
discount = 1.0

for (cf, r) in zip(cf_bond, rate)
    discount = discount / (1 + r)
    pv = pv + discount * cf
end
pv
```

We can easy turn this code into a function so that it can operate on data beyond the single pair of `cf_bond` and `rate` previously defined:

``` julia
function pv(rates,cashflows)
    pv = 0.0
    discount = 1.0

    for (cf, r) in zip(rates, cashflows) # <1>
        discount = discount / (1 + r)
        pv = pv + discount * cf
    end
    pv
end
```

1.  Here, `cf_bond` and `rate` would refer to whatever was passed as arguments to the function instead of any globally defined values.

Now we could use this definition of `pv` on other instances of rates and cashflows.
:::

## Mixing Funcitonal And Imperative Styles

One of the best things about Julia is how natural it can be to mix the different styles Sometimes the best is the mix of both styles and that's one of the benefits of Julia: use the style that's most natural to the problem.

Goal:

``` julia
mapreduce(+,value,zip(rates,discount_factors))
```

## Array-Oriented Styles

Array-oriented programming is one that is practiced in two main contexts:

1.  GPU programming
2.  Python numerical computing

The former because GPUs want large blocks of similar data to operate in parallel. The latter is because native Python is too slow for many modeling problems so libraries like NumPy,SciPy,and tensor libraries define C++ (or similar) libraries for users to call out to.

Array-oriented programming is not always natural for financial and actuarial applications. Differences in behavior or timing of underling cashflows can make a set of otherwise similar products difficult to capture in nicely gridded arrays. Nonetheless, certain applications (scenario generation, some valuation routines) fit very naturally into this paradigm. Furthermore, for those that work well it's often a great way to extract additional performance due to the parallelization offered via CPU or GPU array programming.

@tbl-array-oriented-example shows the bond present value example in this style. 

+----------------------------------------------+-------------------------------------------------+
| Julia                                        | Python (NumPy)                                  |
+==============================================+=================================================+
| ``` julia                                    | ``` python                                      |
| cf_bond = [10, 10, 10, 10, 110]              | import numpy as np                              |
| rate = [0.05, 0.06, 0.05, 0.04, 0.05]        |                                                 |
|                                              | cf_bond = np.array([10, 10, 10, 10, 110])       |
| discount_factors = cumprod(1 ./ (1 .+ rate)) | rate = np.array([0.05, 0.06, 0.05, 0.04, 0.05]) |
| sum(cf_bond .* discount_factors)             |                                                 |
| ```                                          | discount_factors = np.cumprod(1 / (1 + rate))   |
|                                              | result = np.sum(cf_bond * discount_factors)     |
|                                              | ```                                             |
+----------------------------------------------+-------------------------------------------------+

: Julia's broadcasting makes for an array-oriented style, similar to the approach that would be used with Python's NumPy. {#tbl-array-oriented-example}

The downsides to this style are:

1. Sometimes it is unnatrual because of non-uniformity of the data we are working with. For example if the length of the cashflows were shorter than the discount rates, we would have to perform intermediate steps to shorten or lengthen arrays in order to get them to be the same size.
2. A good bit of runtime performance is lost because the computer needs to allocate and fill many intermediate arrays (note how in @tbl-array-oriented-example, the `discount_factors` needs to instantiate an entirely new vector even though it's only temporariliy used). See more on allocations in @sec-hardware.