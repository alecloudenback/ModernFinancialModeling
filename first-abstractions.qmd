---
author:
  - name: Alec Loudenback
---

# Functional Abstractions {#sec-first-abstractions}

```{julia}
#| echo: false
#| output: false
using Pkg
Pkg.activate("env/first-abstractions")
Pkg.instantiate()
using CairoMakie
```

> The purpose of abstraction is not to be vague, but to create a new semantic level in which one can be absolutely precise. - Edsger Dijkstra (1972)

## Chapter Overview

We demonstrate different approaches to a problem, gradually introducing more reusable or general techniques. These allow you to construct sophisticated models while maintaining consistency and simplicity. We cover imperative programming, functional programming, and recursion.

## Introduction

This chapter centers around a simple task: calculate the present value of a single fixed, risk-free, coupon-paying bond under two different interest rate environments. The focus is on describing different approaches, not adding complexity (no credit spreads, settlement timing, etc.).

Mathematically, the problem is to determine the $\text{Present Value}$, where:

$$
\text{Present Value} = \sum{\text{Cashflow}_t \times \text{Discount Factor}_t}
$$

Where

$$
\text{Discount Factor}_t = \prod^t{\frac{1}{1+\text{Discount Rate}_i}}
$$

```{julia}
cf_bond = [10, 10, 10, 10, 110];
rate = [0.05, 0.06, 0.05, 0.04, 0.05]; # <1>
```

1.  The rates are the one year forward rates for time 0, 1, 2, etc.

We will focus on this first discount vector, and introduce more scenarios later in the chapter.

We will repeatedly solve the same problem before extending it to more examples. It may feel repetitive, but the goal is to highlight variations in approach rather than the problem itself.

## Imperative Style

One of the most familiar programming styles is **imperative**`\index{imperative programming}`{=latex} (or **procedural**`\index{procedural programming}`{=latex}), where we provide explicit, step-by-step instructions to the computer. The programmer defines the data involved and how it moves through the program one step at a time. It commonly uses loops to perform tasks repeatedly or across a set of data. The program's **state** (assignment and logic of variables) is defined and managed by the programmer explicitly.

Here's an imperative style of calculating the present value of the bond.

```{julia}
let
    pv = 0.0 #<1>
    discount = 1.0 #<1>

    for i in 1:length(cf_bond) #<2>
        discount = discount / (1 + rate[i])
        pv = pv + discount * cf_bond[i] # <3>
    end
    pv
end
```

1.  Declare variables to keep track of the discount rate and running total for the present value `pv`
2.  Loop over the length of the cashflow vector.
3.  At each step of the loop, look up (via index `i`) update the discount factor to account for the prevailing rate and add the discounted cashflow to the running total present value.

This style is simple, digestible, and clear. If we were performing the calculation by hand, it would likely follow a pattern very similar to this. Look up the first cashflow and discount rate, compute a discount factor, and subtotal the value. Repeat for the next set of values.

### Iterators

Note that in the prior code example we defined an index variable `i` and had to manually define the range over which it would operate (`1` through the `length` of the bond's cashflow vector). A couple of reasons this could be sub-optimal:

1.  Julia arrays are 1-indexed by default. Some custom arrays (e.g., via OffsetArrays.jl) can use different starting indices: using `eachindex` avoids hard-coding index ranges and works for arrays with arbitrary axes.
2.  We manually perform the lookup of the values within each iteration.

We can solve the first one (partially) by letting Julia return an iterable set of values corresponding to the indices of the `cf_bond` vector. This is an example of an **iterator**`\index{iterator}`{=latex} which is an object upon which we can repeatedly ask for the next value until it tells us to stop.

By using `eachindex` we can get the indices of the vector since Julia already knows what they are:

```{julia}
eachindex(cf_bond) # an efficient index iterator
```

::: callout-note
## Lazy Programming

Lazy evaluation`\index{lazy evaluation}`{=latex}: the result, `{julia} eachindex(cf_bond)`, returns an efficient iterator over valid indices (e.g., `Base.OneTo(5)` for a `Vector`). Iterators represent sequences without allocating per-element containers. You can traverse them directly, or materialize them if needed with collect.

An analogy is that we can write the "set of all numbers from 1 to 100" without writing out each of the 100 numbers, but we are referring to the same thing. In practice this means we can iterate over scenario paths, coupon dates, or bucketized tenors without allocating temporary arrays, which keeps the garbage collector quiet during valuation runs.

An example of operating on a lazy iterator, is that we could find the largest index:

```{julia}
maximum(eachindex(cf_bond)) # operates without materializing all the indices
```

The point is if we have an object that *represents* a set, we need not actually enumerate each element of the set to interact with it.

We can fully instantiate an iterator with `collect`

```{julia}
collect(eachindex(cf_bond))  # materialize indices as a Vector
```

Laziness is generally a good thing in programming because sometimes it can be computationally or memory expensive to fully instantiate the collection of interest (this will be discussed further in @sec-hardware).
:::

And when used in context:

```{julia}
let
    pv = 0.0
    discount = 1.0

    for i in eachindex(cf_bond)
        discount = discount / (1 + rate[i])
        pv = pv + discount * cf_bond[i]
    end
    pv
end
```

Here Julia gave us the index associated with the bond cashflows, but we are still looking up the values (why not just ask for the values instead of their index?) as well as assuming that the indices are the same for the discount rates.

We can get the value and the associated index with `enumerate`:

```{julia}
collect(enumerate(cf_bond))
```

This would allow us to skip the step of needing to look up the bond's cashflows. However, we can go even further by just asking for value associated with both collections. With `zip` (named because it's sort of like zipping up two collections together), we get an iterator that provides the values of the underlying collections:

```{julia}
collect(zip(cf_bond, rate))
```

This provides the simplest implementation of the imperative approaches:

```{julia}
let
    pv = 0.0
    discount = 1.0

    for (cf, r) in zip(cf_bond, rate)
        discount = discount / (1 + r)
        pv = pv + discount * cf
    end
    pv
end
```

The primary downsides to iterative approaches to algorithms are:

1.  Needing to keep track of state is fine in simple cases, but can quickly become difficult to reason about and error prone as the number and complexity of variables grows.
2.  Program flow is explicitly stated, leaving fewer places that the compiler can automatically optimize or parallelize.

::: callout-tip
In the imperative style, we mentioned needing to explicitly handle program state. In general, it's advisable to minimize as many temporary state variables as possible - more mutability tends to produce more complex, difficult to maintain code. An example of maintaining state in the examples above is keeping track of the current index as well as interim `pv` and `discount` variables.

Avoiding modifying values is often avoidable by restructuring the logic, using functional techniques, or finding the right abstractions. However, sometimes for performance reasons, clarity, or expediency you may find modifying state to be the preferred option and that's okay.
:::

## Functional Techniques and Terminology

**Functional** programming`\index{functional programming}`{=latex} is a paradigm which attempts to minimize state via composing functions together.

@tbl-functional-methods introduces a set of core functional methods to familiarize yourself with. Note that anonymous functions (@sec-anonymous-functions) are used frequently to define intermediary steps.

::: landscape
+--------------------------+---------------------------------------------------------------------------------------------------------------------------------------+---------------+
| Function                 | Description                                                                                                                           | Example       |
+:=========================+:======================================================================================================================================+:==============+
| `map(f,v)`               | Apply function `f` to each element of the collection `v`.                                                                             | ``` julia     |
|                          |                                                                                                                                       | map(          |
|                          |                                                                                                                                       |     x->x^2,   |
|                          |                                                                                                                                       |     [1,3,5]   |
|                          |                                                                                                                                       | ) # [1,9,25]  |
|                          |                                                                                                                                       | ```           |
+--------------------------+---------------------------------------------------------------------------------------------------------------------------------------+---------------+
| `reduce(op,v)`           | Apply binary `op` to pairs of values, reducing the dimension of the collection `v`.\                                                  | ``` julia     |
|                          | \                                                                                                                                     | reduce(       |
|                          | Has a couple of important, optional keyword arguments to note (which also apply to other variants of `reduce` below):                 |     *,        |
|                          |                                                                                                                                       |     [1,3,5]   |
|                          | -   `init` defines the identity element (e.g. the initial value of `+` and `*` is `0` and `1` respectively)                           | ) # 15        |
|                          | -   `dims` defines which dimension to reduce across (if the dimension of `v` is more than one).                                       | ```           |
+--------------------------+---------------------------------------------------------------------------------------------------------------------------------------+---------------+
| `mapreduce(f,op,v)`      | Maps `f` over collection `v` and returns a reduced result using `op`.                                                                 | ``` julia     |
|                          |                                                                                                                                       | mapreduce(    |
|                          |                                                                                                                                       |     x->x^2,   |
|                          |                                                                                                                                       |     *,        |
|                          |                                                                                                                                       |     [1,3,5]   |
|                          |                                                                                                                                       | ) # 225       |
|                          |                                                                                                                                       | ```           |
+--------------------------+---------------------------------------------------------------------------------------------------------------------------------------+---------------+
| `foldl(op,v)foldr(op,v)` | Like `reduce`, but applies `op` from left to right (`foldl`) or right to left (`foldr`). Also has `mapfoldl` and `mapfoldr` versions. | ``` julia     |
|                          |                                                                                                                                       | foldl(        |
|                          |                                                                                                                                       |     *,        |
|                          |                                                                                                                                       |     [1,3,5]   |
|                          |                                                                                                                                       | ) # 15        |
|                          |                                                                                                                                       | ```           |
+--------------------------+---------------------------------------------------------------------------------------------------------------------------------------+---------------+
| `accumulate(op,v)`       | Apply `op` along `v` , creating a vector with the cumulative result.                                                                  | ``` julia     |
|                          |                                                                                                                                       | accumulate(   |
|                          |                                                                                                                                       |     +,        |
|                          |                                                                                                                                       |     [1,3,5]   |
|                          |                                                                                                                                       | ) # [1, 4, 9] |
|                          |                                                                                                                                       | ```           |
+--------------------------+---------------------------------------------------------------------------------------------------------------------------------------+---------------+
| `filter(f,v)`            | Apply `f` along `v` and return a copy of `v` with elements where `f` is true                                                          | ``` julia     |
|                          |                                                                                                                                       | filter(       |
|                          |                                                                                                                                       |     >=(3),    |
|                          |                                                                                                                                       |     [1,3,5]   |
|                          |                                                                                                                                       | ) # [3, 5]    |
|                          |                                                                                                                                       | ```           |
+--------------------------+---------------------------------------------------------------------------------------------------------------------------------------+---------------+

: Important Functional Methods. {#tbl-functional-methods tbl-colwidths="\[25,45,30\]"}
:::

This paradigm is very powerful in a few ways:

1.  It provides a language for talking about what a computation is doing. Instead of "looping over a collection called `portfolio` and calling a `value` function" we can more concisely refer to this as `mapreduce(value,portfolio)`.
2.  Often you are forced to think about the design of the program more deeply, recognizing the core calculations and data used within the model.
3.  The compiler is free to apply more optimizations. For example, with `reduce`, the compiler could optimize the calculation since the operation is assumed to be associative.
4.  The lack of mutable state.

Let's build a version of the present value calculation using the functional building blocks described above. In practice these patterns show up when aggregating P&L across books, summing hedges across currencies, or transforming raw trades into risk factors. We will work up to the bond example by discussing the core building blocks—`map`, `accumulate`, `reduce`—and culminate in combining them with `mapreduce`.

### `map`

**`map`** `\index{map (function)}`{=latex} is so named for the mathematical concept of mapping an input to an output. Here, it's effectively the same thing. We take a collection and use the given function to calculate an output. The size of the output equals the size of the input.

First, we will use `map` to compute the one-period discount factors:

```{julia}
map(x -> 1 / (1 + x), rate)
```

`map` transforms the `rate` collection by applying the anonymous function `x -> 1 / (1 + x)`, which is the single period discount factor used in discount curve construction. This operation is conveyed visually in @fig-map-diagram.

```{julia}
#| label: fig-map-diagram
#| fig-cap: "A diagram showing that `map` creates a new collection mirroring the old one, after applying the given function to each element in the original collection."
#| echo: false
let
    fig = Figure()
    ax = Axis(fig[1,1],
        limits=((-0.5, 10.5), (-0.5, 5.5)),
        aspect=2.5)
    hidedecorations!(ax)
    hidespines!(ax)

    # Input values
    inputs = ["0.05", "0.06", "0.05", "0.04", "0.05"]
    outputs = ["0.9524", "0.9434", "0.9524", "0.9615", "0.9524"]

    # Draw input boxes (left column)
    for (i, val) in enumerate(inputs)
        y = 6 - i
        poly!(ax, Rect(0, y-0.4, 1.2, 0.8), color=:lightblue, strokewidth=1, strokecolor=:black)
        text!(ax, 0.6, y, text=val, align=(:center, :center), fontsize=12)
    end
    text!(ax, 0.6, 5.8, text="Input (rate)", align=(:center, :bottom), fontsize=11, font=:bold)

    # Draw function boxes (middle column)
    for i in 1:5
        y = 6 - i
        poly!(ax, Rect(3.5, y-0.4, 1.8, 0.8), color=:lightgreen, strokewidth=1, strokecolor=:black)
        text!(ax, 4.4, y, text="1/(1+x)", align=(:center, :center), fontsize=11)
    end
    text!(ax, 4.4, 5.8, text="Function", align=(:center, :bottom), fontsize=11, font=:bold)

    # Draw output boxes (right column)
    for (i, val) in enumerate(outputs)
        y = 6 - i
        poly!(ax, Rect(7.8, y-0.4, 1.4, 0.8), color=:lightpink, strokewidth=1, strokecolor=:black)
        text!(ax, 8.5, y, text=val, align=(:center, :center), fontsize=12)
    end
    text!(ax, 8.5, 5.8, text="Output", align=(:center, :bottom), fontsize=11, font=:bold)

    # Draw arrows
    for i in 1:5
        y = 6 - i
        arrows2d!(ax, [1.2, 5.3], [y, y], [2.0, 2.2], [0, 0], color=:gray, shaftwidth=1)
    end

    fig
end
```

::: callout-tip
`map` is an absolute workhorse of a function and the authors recommend using it liberally within your code. We find ourselves using `map` frequently, usually avoiding defining an explicit loop (unless we are modifying some existing collection).

`map` would likely be a better tool for a loop like this:

``` julia
output = []
for x in collection
    result = # ... do stuff ...
    push!(output,result)
end
output
```

Instead, `map` simplifies this to:

``` julia
map(collection) do x
    # ... do stuff
end
```

Not only does this have the advantage of being clearer, more concise, and less work, it also lets Julia infer the output type of your computation so you don't have to worry about the type of `output`.
:::

### `accumulate`

`accumulate` `\index{accumulate (function)}`{=latex} takes an operation and a collection and returns a collection where each element is the cumulative result of applying the operation from the first element to the current one. For example, to calculate the cumulative product of the one-period discount factors:

```{julia}
let
    rates =
        accumulate(*, map(x -> 1 / (1 + x), rate))
end
```

This results in a vector of the cumulative discount factors for each point in time corresponding to the given cashflows.

```{julia}
#| label: fig-accumulate-diagram
#| fig-cap: "A diagram showing that `accumulate` creates a new collection where each element is the cumulative result of applying the given operation to all previous elements."
#| echo: false
let
    fig = Figure()
    ax = Axis(fig[1,1],
        limits=((-0.5, 12), (-0.5, 6.5)),
        aspect=2)
    hidedecorations!(ax)
    hidespines!(ax)

    inputs = ["0.9524", "0.9434", "0.9524", "0.9615", "0.9524"]
    ops = ["df₁ × init", "df₂ × out₁", "df₃ × out₂", "df₄ × out₃", "df₅ × out₄"]
    outputs = ["0.9524", "0.8985", "0.8561", "0.8230", "0.7831"]

    # Draw input boxes
    for (i, val) in enumerate(inputs)
        y = 6 - i
        poly!(ax, Rect(0, y-0.4, 1.4, 0.8), color=:lightblue, strokewidth=1, strokecolor=:black)
        text!(ax, 0.7, y, text=val, align=(:center, :center), fontsize=11)
    end
    text!(ax, 0.7, 5.8, text="Input", align=(:center, :bottom), fontsize=11, font=:bold)

    # Draw operation boxes
    for (i, op) in enumerate(ops)
        y = 6 - i
        poly!(ax, Rect(3.5, y-0.4, 2.2, 0.8), color=:lightgreen, strokewidth=1, strokecolor=:black)
        text!(ax, 4.6, y, text=op, align=(:center, :center), fontsize=10)
    end
    text!(ax, 4.6, 5.8, text="Operation (*)", align=(:center, :bottom), fontsize=11, font=:bold)

    # Draw output boxes
    for (i, val) in enumerate(outputs)
        y = 6 - i
        poly!(ax, Rect(8, y-0.4, 1.4, 0.8), color=:lightpink, strokewidth=1, strokecolor=:black)
        text!(ax, 8.7, y, text=val, align=(:center, :center), fontsize=11)
    end
    text!(ax, 8.7, 5.8, text="Output", align=(:center, :bottom), fontsize=11, font=:bold)

    # Draw init box
    poly!(ax, Rect(8, 5.6, 1.4, 0.6), color=:lightyellow, strokewidth=1, strokecolor=:black)
    text!(ax, 8.7, 5.9, text="init=1.0", align=(:center, :center), fontsize=10)

    # Arrows: input -> operation
    for i in 1:5
        y = 6 - i
        arrows2d!(ax, [1.4], [y], [1.8], [0.0], color=:gray, shaftwidth=1)
    end

    # Arrows: operation -> output
    for i in 1:5
        y = 6 - i
        arrows2d!(ax, [5.7], [y], [2.0], [0.0], color=:gray, shaftwidth=1)
    end

    # Arrows: output feeds back to next operation (curved feedback)
    for i in 1:4
        y_from = 6 - i
        y_to = 6 - (i + 1)
        # Draw a simple down-and-left path
        lines!(ax, [8.7, 8.7, 6.5, 5.7], [y_from - 0.4, y_to + 0.15, y_to + 0.15, y_to],
               color=:steelblue, linewidth=1, linestyle=:dash)
    end

    # Arrow from init to first operation
    lines!(ax, [8.7, 8.7, 6.5, 5.7], [5.6, 5.15, 5.15, 5.0],
           color=:steelblue, linewidth=1, linestyle=:dash)

    fig
end
```

::: callout-note
For `accumulate` and `reduce`, an important, optional value is the `init` (an optional keyword argument), which is the initial value to start the accumulation or reduction. For common operations this **identity element** is already predefined. For example, for `+` the identity is `0` while for `*` it is `1`. The identity element $e$ is the one where for a given binary operation $\bigodot$, that $x \bigodot e = x$.

Another example is string concatenation. In Julia, two strings are concatenated with `*` (like in mathematics, $a * b$ is also written as $ab$). The identity element for strings where the binary operation $\bigodot = *$ is `""`. For example:

```{julia}
accumulate(*, ["a", "b", "c"], init="")
```

*This is a taste of a branch of mathematics known as Category Theory, a very rich subject but largely beyond the immediate scope of this book. The category theoretical term for sets of things that work with the binary operator and identity elements as described above is a **monoid**. There will not be a quiz on this trivia.*
:::

### `reduce`

`reduce` `\index{reduce (function)}`{=latex} takes an operation and a collection and applies the operation repeatedly to pairs of elements until there is only a single value left.

For example, we start with the calculation of the vector of discounted cashflows

```{julia}
dfs = accumulate(*, map(x -> 1 / (1 + x), rate))
discounted_cfs = map(*, cf_bond, dfs)
```

Then we can sum them with reduce:

```{julia}
reduce(+, discounted_cfs)
```

```{julia}
#| label: fig-reduce-diagram
#| fig-cap: "A diagram showing how `reduce` applies the given operation to pairs of elements, ultimately reducing the collection to a single value."
#| echo: false
let
    fig = Figure()
    ax = Axis(fig[1,1],
        limits=((-0.5, 12), (-0.5, 6.5)),
        aspect=2)
    hidedecorations!(ax)
    hidespines!(ax)

    inputs = ["9.52", "8.98", "8.56", "8.23", "86.20"]
    ops = ["0.0 + cf₁", "acc + cf₂", "acc + cf₃", "acc + cf₄", "acc + cf₅"]

    # Draw input boxes
    for (i, val) in enumerate(inputs)
        y = 6 - i
        poly!(ax, Rect(0, y-0.4, 1.3, 0.8), color=:lightblue, strokewidth=1, strokecolor=:black)
        text!(ax, 0.65, y, text=val, align=(:center, :center), fontsize=11)
    end
    text!(ax, 0.65, 5.8, text="Input", align=(:center, :bottom), fontsize=11, font=:bold)

    # Draw operation boxes (stacked vertically to show reduction)
    for (i, op) in enumerate(ops)
        y = 6 - i
        poly!(ax, Rect(3.5, y-0.4, 2.2, 0.8), color=:lightgreen, strokewidth=1, strokecolor=:black)
        text!(ax, 4.6, y, text=op, align=(:center, :center), fontsize=10)
    end
    text!(ax, 4.6, 5.8, text="Reduce (+)", align=(:center, :bottom), fontsize=11, font=:bold)

    # Draw final output box
    poly!(ax, Rect(8, 2.6, 1.6, 0.8), color=:lightpink, strokewidth=1, strokecolor=:black)
    text!(ax, 8.8, 3.0, text="121.49", align=(:center, :center), fontsize=12, font=:bold)
    text!(ax, 8.8, 3.6, text="Output", align=(:center, :bottom), fontsize=11, font=:bold)

    # Arrows: input -> operation
    for i in 1:5
        y = 6 - i
        arrows2d!(ax, [1.3], [y], [1.9], [0.0], color=:gray, shaftwidth=1)
    end

    # Arrows: operation -> next operation (chain of reductions)
    for i in 1:4
        y_from = 6 - i
        y_to = 6 - (i + 1)
        arrows2d!(ax, [4.6], [y_from - 0.4], [0.0], [y_to - y_from + 0.8], color=:steelblue, shaftwidth=1.5)
    end

    # Arrow from last operation to output
    arrows2d!(ax, [5.7], [1.0], [2.0], [1.8], color=:steelblue, shaftwidth=1.5)

    fig
end
```

### `mapreduce` {#sec-map-reduce}

We can combine `map`, `accumulate` and `reduce` to concisely calculate the present value`\index{present value}`{=latex} in a functional style using `mapreduce` `\index{mapreduce (function)}`{=latex}. This calculates the discount factors, applies them to the cashflows with map, and sums the result with a reduction:

```{julia}
dfs = accumulate(*, map(x -> 1 / (1 + x), rate)) # <1>
mapreduce(*, +, cf_bond, dfs) # <2>
```

1.  Multiplicatively accumulate a discount factor derived from the rate vector.
2.  Multiply the discount factor and bond cashflows (map the multiplication), then sum the result (additive reduce).

Contrast this example with the earlier imperative styles:

-   This functional approach is more concise.
-   The functions used are more descriptive and obvious (once familiar with them, of course!).
-   There is no state that the user/programmer keeps track of.
-   The compiler is able to potentially optimize the code, as it can deduce that certain operations are associative.

This completes the example of using a functional approach to determine the present value of bond cashflows.

### `filter`

For completeness, we will also cover `filter` even though it's not necessary for the bond cashflow example.

`filter` `\index{filter (function)}`{=latex} does what you might think - filter a collection based on some criterion that can be determined as true or false.

For example filtering out even numbers using the `isodd` function:

```{julia}
filter(isodd, 1:6)
```

Or filtering out things that don't match a criteria:

```{julia}
filter(x -> ~(x == 5), 1:6)
```

While we didn't need `filter` to calculate a bond's present value in the example above, one can imagine how you may want to filter dates that a bond might pay a cashflow, say last day of a quarter:

```{julia}
using Dates
let d = Date(2024, 01, 01)
    filter(d -> lastdayofquarter(d) == d, d:Day(1):lastdayofyear(d))
end
```

### More Tips on Functional Styles

#### `do` Syntax for Function Arguments

In more complex situations such as with multiple collections or multi-line logic, there is a clearer syntax that is often used. `do` is a reserved keyword in Julia that creates an anonymous function and passes its arguments to a function like `map`. For example, this (terrible) code which decides if a number is prime. The anonymous function requires a `begin` block since the logic of the function is extended into multiple lines.

```{julia}
map(x -> begin
        if x == 1
            "prime"
        elseif x == 2
            "not prime"
        elseif x == 3
            "prime"
        elseif x > 4
            "probably not prime"
        end
    end,
    [1, 2, 3, 10]
)
```

This can be written more cleanly with the `do` syntax:

```{julia}
map([1, 2, 3, 10]) do x
    if x == 1
        "prime"
    elseif x == 2
        "not prime"
    elseif x == 3
        "prime"
    elseif x > 4
        "probably not prime"
    end
end
```

#### Multiple Collections

`map` and the other functional operators discussed in this section can take multiple arguments. This is convenient if you have multiple arguments to a function:

```{julia}
discounts = [0.9, 0.81, 0.73]
cashflows = [10, 10, 10]

map((d, c) -> d * c, discounts, cashflows)
```

Or an example with the `do` syntax:

```{julia}
map(discounts, cashflows) do d, c
    d * c
end
```

#### Using More Functions

At the risk of sounding obvious, an easy way to make the program more "functional" is to simply use more functions. Do this one thing and it will improve the model's organization, maintainability, and reduce bugs!

Take the example from earlier:

``` julia
pv = 0.0
discount = 1.0

for (r,cf) in zip(cf_bond, rate)
    discount = discount / (1 + r)
    pv = pv + discount * cf
end
pv
```

We can easily turn this code into a function so that it can operate on data beyond the single pair of `cf_bond` and `rate` previously defined:

``` julia
function pv(rates,cashflows)
    pv = 0.0
    discount = 1.0

    for (r,cf) in zip(rates, cashflows) # <1>
        discount = discount / (1 + r)
        pv = pv + discount * cf
    end
    pv
end
```

1.  Here, `cf_bond` and `rate` would refer to whatever was passed as arguments to the function instead of any globally defined values.

Now we could use this definition of `pv` on other instances of rates and cashflows.

#### Mixing Functional And Imperative Styles

One of the best things about Julia is how natural it can be to mix different styles. Sometimes the best approach is a mix of both. That's one of the benefits of Julia: use the style that's most natural to the problem.

::: callout-note
## Flexibility and the Lisp Curse

**Lisp**`\index{Lisp}`{=latex} ("list processing") is another, much older language than Julia (created in the 1950s!). One of its claims to fame is how flexible and powerful the tools are within the language to build upon. There's a couple aspects of this curse that we wish to describe because we can learn from it while Julia is still a relatively young language.

Part of the "curse" is that: because there's so much freedom in what can be expressed in the language, there's not an obvious "best" way of doing things. This can lead to decision paralysis where you are trying to over-analyze what's the best way to write part of your code. Our advice: *don't worry about it!* A working implementation of something is better than an over-optimized idea.

The other part of the "curse" is that because it is relatively easy to implement so many things from the building blocks that Julia provides and compose them together to do what you want. This has a downside because the general approach to packages is smaller, standalone pieces that you compose as needed. For example, consider Python's Pandas library, upon which Python's data science community was built. It came bundled with a CSV reader, Excel reader, Database reader, DataFrame type, visualization library, and statistical functions. In Julia, each of those are separate packages that specialize for the respective topics. This is advantageous in that they can progress independently from one another, you don't have to include functionality that you don't need, and you can mix and match libraries depending on your preference.
:::

## Array-Oriented Styles {#sec-array-oriented-styles}

Another paradigm is **array-oriented**`\index{array-oriented programming}`{=latex}**,** which is a style that relies heavily on putting similar data into arrays and operating on the entire array at the same time (as opposed to going element-by-element).

Array-oriented programming is practiced in two main contexts:

1.  GPU programming
2.  Python numerical computing

The former because GPUs want large blocks of similar data to operate in parallel. The latter is because native Python is too slow for many modeling problems so libraries like NumPy, SciPy, and tensor libraries utilize C++ (or similar) libraries for users to call out to.

Array-oriented programming is not always natural for financial and actuarial applications. Differences in behavior or timing of underling cashflows can make a set of otherwise similar products difficult to capture in nicely gridded arrays. Nonetheless, certain applications (scenario generation, some valuation routines) fit very naturally into this paradigm. Furthermore, for those that work well it's often a great way to extract additional performance due to the parallelization offered via CPU or GPU array programming.

@tbl-array-oriented-example shows the bond present value example in this style.

:::landscape
+----------------------------------------------+-------------------------------------------------+
| Julia                                        | Python (NumPy)                                  |
+==============================================+=================================================+
| ``` julia                                    | ``` python                                      |
| cf_bond = [10, 10, 10, 10, 110]              | import numpy as np                              |
| rate = [0.05, 0.06, 0.05, 0.04, 0.05]        |                                                 |
|                                              | cf_bond = np.array([10, 10, 10, 10, 110])       |
| discount_factors = cumprod(1 ./ (1 .+ rate)) | rate = np.array([0.05, 0.06, 0.05, 0.04, 0.05]) |
| result = sum(cf_bond .* discount_factors)    |                                                 |
| ```                                          | discount_factors = np.cumprod(1 / (1 + rate))   |
|                                              | result = np.sum(cf_bond * discount_factors)     |
|                                              | ```                                             |
+----------------------------------------------+-------------------------------------------------+

: The two code examples demonstrate the same logic using Julia and Numpy (Python's most popular array package). Julia's broadcasting facilitates an array-oriented style, similar to the approach that would be used with Python's NumPy. {#tbl-array-oriented-example}
:::

The downsides to this style are:

1.  Sometimes it is unnatural because of non-uniformity of the data we are working with. For example if the length of the cashflows were shorter than the discount rates, we would have to perform intermediate steps to shorten or lengthen arrays in order to get them to be the same size.
2.  A good bit of runtime performance is lost because the computer needs to allocate and fill many intermediate arrays (note how in @tbl-array-oriented-example, the `discount_factors` needs to instantiate an entirely new vector even though it's only temporarily used). See more on allocations in @sec-hardware.

## Recursion

A **recursive function**`\index{recursion}`{=latex} which is a pattern where current steps are defined in a way that depends on previous steps. Typically, an explicit starting condition is also required to be specified.

The Fibonacci sequence`\index{Fibonacci sequence}`{=latex} is a classic example of a recursive algorithm, with the starting conditions of $n$ specified for the first two steps:

$$F(n) = \begin{cases}
0, & \text{if } n = 0\\
1, & \text{if } n = 1\\
F(n-1) + F(n-2), & \text{if } n > 1
\end{cases}$$

In code, this translates into a function definition that refers to itself:

``` julia
function fibonacci(n)
    if n == 0
        return 0
    elseif n == 1
        return 1
    else
        return fibonacci(n-1) + fibonacci(n-2)
    end
end
```

How could a recursive pattern be defined for valuing our bond? A possible pattern is defining the present value to be the discounted value of:

-   the current period's cashflow, *plus*

-   the accumulated cashflows up to that point in time

Here's how that might be defined:

```{julia}
function pv_recursive(rates,cashflows,accumulated_value=0.0,discount_factor=1.0)
  if isempty(cashflows) #<1>
    return accumulated_value
  else
    discount_factor = discount_factor / (1+first(rates)) # <2>
    av = first(cashflows) * discount_factor + accumulated_value # <3>
    remaining_rates = rates[begin+1:end]
    remaining_cfs = cashflows[begin+1:end]
    return pv_recursive(remaining_rates,remaining_cfs, av,discount_factor) # <4>
  end
end

```

1.  Add a terminating condition, that if we have no more cashflows then return the accumulated value.
2.  Decrement the discount factor as we step forward in time.
3.  Take the prior accumulated value and add the first value in the given cashflows.
4.  Pass the remaining subset of the cashflow vector, the running total, and the current discount factor to the next call of the recursive function.

And an example of its use:

```{julia}
pv_recursive(rate,cf_bond)
```

The recursive pattern often works very nicely for simpler examples. However, more complex logic and conditionals can make this approach unwieldy. Nonetheless, attempting to distill the desired functionality into a single function can be a beneficial thought exercise.
