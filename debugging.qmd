# Debugging and Performance Measurement

> “Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it.” Brian Kernighan

```{julia}
#| echo: false
#| output: false
using Pkg
Pkg.activate("env/debugging")
Pkg.instantiate()
```

## Setup

```{julia}
using BenchmarkTools
using Logging
using Infiltrator
```

## Benchmarking {#sec-benchmarking}

Benchmarking is the process of evaluating performance by comparing it to a standard or a set of best practices. Julia provides handy benchmarking tools for performance measurement.

```{julia}
function example_function(n)
    sum = 0
    for i in 1:n
        sum += i^2
    end
    return sum
end

# Benchmark the function
@btime example_function(1000)
@btime example_function(2000)
```

## Debugging {#sec-debugging}

Debugging in Julia involves identifying and fixing errors or bugs in your code. Julia provides several tools and techniques to aid in debugging.

- Using print and println Statements

The simplest form of debugging involves adding print or println statements to output variable values or checkpoints in your code. This helps track the flow and state of execution.

```{julia}
function add(a, b)
    println("a: ", a)
    println("b: ", b)
    result = a + b
    println("result: ", result)
    return result
end

add(3, 5)
```

- Using the Debugger Package

Julia has a powerful debugger package called Debugger.jl, which allows us to step through code, set breakpoints, and inspect variables. Note that this needs to be run in an interactive session (e.g. the REPL or Jupyter).

```julia
function example_function(x)
    y = x * 2
    @enter begin
        z = y + 1
        return z
    end
end

example_function(5)
```

When the debugger is started, we can interactively inspect variables, step through the code, and continue execution.

* Commands
Some common commands in the debugger are:

  - `n` (Next): Step to the next line of code.
  - `s` (Step): Step into the function call.
  - `c` (Continue): Continue execution until the next breakpoint or the end of the program.
  - `p` (Print): Print the value of a variable.

- Using @debug Logging

The Logging module in Julia allows ud to log messages at different levels (e.g., @debug, @info, @warn, @error). This is useful for more controlled logging compared to print statements.

```{julia}
function compute(x)
    @debug "Starting computation with x = $x"
    y = x^2
    @debug "Computed y = $y"
    return y
end

compute(10)
```

To see debug logs, it is necessary to configure the logging level:

global_logger(ConsoleLogger(stderr, Logging.Debug))

- Using Infiltrator for Interactive Debugging

The Infiltrator.jl package provides another approach to interactive debugging by letting you insert debugging sessions into your code.

```{julia}
function compute(x)
    @infiltrate
    y = x^2
    return y
end

compute(10)
```

When execution reaches the @infiltrate line, it will drop us into an interactive prompt where we can inspect variables and execute commands.

- Error Messages and Stack Traces

Julia’s error messages and stack traces can be quite informative. When an error occurs, Julia provides a traceback that shows the function call stack leading to the error, which helps in identifying where things went wrong.

```{julia}
function faulty_function(x)
    return 1 / x
end

faulty_function(0)  # This will raise a `DivisionError`
```

The traceback will show us the sequence of function calls that led to the error.

Debugging in Julia involves a mix of strategies, including using print statements, the Debugger package for step-by-step inspection, logging with the Logging module, and interactive debugging with Infiltrator. These tools and techniques can help you identify and fix issues in our code efficiently.
