# Sensitivity Analysis

[Drafting note: based on some examples. Needs to be revised with more exposition.]

## In This Chapter

Different approaches to understanding the sensitivity of a model to changes in its inputs: derivatives, finite differences, global sensitivity analysis approaches, and statistical approaches.

```{julia}
#| echo: false
#| output: false
using Pkg
Pkg.activate("env/sensitivity")
Pkg.instantiate()
```

## Setup

```{julia}
#| output: false
import Pkg; Pkg.add("MortalityTables"); Pkg.add("GlobalSensitivity"); Pkg.add("QuasiMonteCarlo")
using CSV, DataFrames
using MortalityTables, Dates
using GlobalSensitivity
using QuasiMonteCarlo
using CairoMakie
```

```{julia}
@enum Sex Female = 1 Male = 2
@enum Risk Standard = 1 Preferred = 2

mutable struct Policy
    id::Int
    sex::Sex
    benefit_base::Float64
    COLA::Float64
    mode::Int
    issue_date::Date
    issue_age::Int
    risk::Risk
end

```

## The Data

```{julia}
sample_csv_data =
    IOBuffer(
        raw"id,sex,benefit_base,COLA,mode,issue_date,issue_age,risk
         1,M,100000.0,0.03,12,1999-12-05,30,Std"
    )

mort = Dict(
    Male => MortalityTables.table(988).ultimate,
    Female => MortalityTables.table(992).ultimate,
)
```

```{julia}
policies = let

    # read CSV directly into a dataframe
    # df = CSV.read("sample_inforce.csv",DataFrame) # use local string for notebook
    df = CSV.read(sample_csv_data, DataFrame)

    # map over each row and construct an array of Policy objects
    map(eachrow(df)) do row
        Policy(
            row.id,
            row.sex == "M" ? Male : Female,
            row.benefit_base,
            row.COLA,
            row.mode,
            row.issue_date,
            row.issue_age,
            row.risk == "Std" ? Standard : Preferred,
        )
    end

end
```

Given a basic insurance product, a pure whole of life (WOL) policy with level benefits and level premiums payable within the first 10 years, the reserve at the end of the $y^th$ policy year is defined by

$$
res(y) = \sum_{t=age+y}^{120} (sur_(t-age-y) * mort_t * B_y * \sqrt(1 + r)) - (P_y * sur_(t-age-y))
$$

where

- $mort_t$ is the mortality at age $t$
- $p_y$ is the survival probability adjusted with COLA, with values of $p_(y-1) = 1$ and $p_x = p_(x-1) * (1 - mort_(age+y)) / (1 + COLA)$ for $x >= y$, and 0 for $x < y - 1$ or $age + x >= 120$, or ultimate age of the current mortality table
- $B_y$ is the level benefit throughout the policy
- $P_y$ is the level premium within the first 10 policy years which is 0 for policy years after 10
- $r$ is the level interest rate throughout the policy

```{julia}
function sur(y::Int, pol::Policy)
    if y == 0
        1
    elseif y < 0 || 120 - y <= pol.issue_age
        0
    else
        sur(y - 1, pol) * (1 - mort[pol.sex][pol.issue_age + y]) / (1 + pol.COLA)
    end
end

function res(y::Int, pol::Policy, P::Float64)
    s = 0.0
    if y >= 1 && y <= 120 - pol.issue_age
        for t in (pol.issue_age + y):120
            prem = 0.0
            if y <= 9
                prem = P
            end 
            s += sur(t - pol.issue_age - y, pol) * mort[pol.sex][t] * pol.benefit_base - prem * sur(t - pol.issue_age - y, pol)
        end
    end
    s
end

```

## Common Sensitivity Analysis Methodologies

### Finite Differences

Define a customized finite difference function with respect to the COLA, rippled by a small difference.

```{julia}
function res_wrt_r_fd(y::Int, pol::Policy, P::Float64, r::Float64, h=1e-3)
    p₊, p₋ = deepcopy(pol), deepcopy(pol)
    p₊.COLA = r + h, p₋.COLA = r - h
    (res(y, p₊, P) - res(y, p₋, P)) / (2h)
end
```

### Scenario Analyses

Scenarios can be generated following scenario generation methodologies to evaluate impacts. Refer to scenario generation chapter.

### Regression Analyses

```{julia}
function r1_wrt_r(r)
    p = deepcopy(policies[1])
    p.COLA = r[2]
    res(Int(floor(r[1])), p, r[3])
end

gsa(r1_wrt_r, RegressionGSA(), [[1, 1.01], [0.025, 0.035], [10000.0, 10000.1]], samples = 1000)
```

### Sobol Indices

Sobol is a variance-based method, and it decomposes the variance of the output of the model or system into fractions which can be attributed to inputs or sets of inputs. This helps to get not just the individual parameter's sensitivities, but also gives a way to quantify the affect and sensitivity from the interaction between the parameters.

The Sobol Indices are "order"ed, the first order indices given by 
​
  the contribution to the output variance of the main effect of 
​
 . Therefore, it measures the effect of varying 
​
  alone, but averaged over variations in other input parameters. It is standardized by the total variance to provide a fractional contribution. Higher-order interaction indices 
​
  and so on can be formed by dividing other terms in the variance decomposition by 
Var(Y).

```{julia}
L, U = QuasiMonteCarlo.generate_design_matrices(1000, [1, 0.025, 10000.0], [1, 0.035, 10000.1], SobolSample())
gsa(r1_wrt_r, Sobol(), L, U)
```

### Morris Method

The Morris method also known as Morris’s OAT method where OAT stands for One At a Time can be described in the following steps:

$$
EE_i = \frac{f(x_1, x_2, ...x_i + \Delta, ...x_k) - y}{\Delta}
$$

We calculate local sensitivity measures known as “elementary effects”, which are calculated by measuring the perturbation in the output of the model on changing one parameter.

These are evaluated at various points in the input chosen such that a wide “spread” of the parameter space is explored and considered in the analysis, to provide an approximate global importance measure. The mean and variance of these elementary effects is computed. A high value of the mean implies that a parameter is important, a high variance implies that its effects are non-linear or the result of interactions with other inputs. This method does not evaluate separately the contribution from the interaction and the contribution of the parameters individually and gives the effects for each parameter which takes into consideration all the interactions and its individual contribution.

```{julia}
m = gsa(r1_wrt_r, Morris(), [[1, 1.01], [0.025, 0.035], [10000.0, 10000.1]])
```

### Fourier Amplitude Sensitivity Tests

```{julia}
gsa(r1_wrt_r, eFAST(), [[1, 1.01], [0.025, 0.035], [10000.0, 10000.1]], samples = 1000)
```

## Benchmarking
