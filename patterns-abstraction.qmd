# Patterns of Abstraction {#sec-patterns-abstractions}

> "Simple things should be simple, complex things should be possible." — Alan Kay (1970s)

## In this section

We extend the building blocks from the prior section and talk about how to combine them into more abstract patterns to simplify the design of our programs. Data driven design, object oriented design versus composition, multiple dispatch, and interfaces.

## Introduction

Abstraction is a selective ignorance—focusing on the aspects of the problem that are relevant, and ignoring the others. At different times we are interested in different rungs on the **ladder of abstraction**: sometimes we are interested in the small details, but other times we are interested in understanding the behavior of systems at a higher level.

There's multiple dimensions to this. We could be talking about either *abstractions within the model* (such as: what datatype and methods should be used to represent this financial contract) and *abtractions of analysis* (such as: what are the partial derivatives, or "greeks", of this financial contract). In fact, a lot of designing a model is essentially trying to figure out where to put the right abstractions for both of these. What is the right level of detail to model this in and what is the right level of detail to expose to other systems? Are we most interested in a single point result or understanding the relationship between two variables?

We will briefly cover the latter, as the concepts are repeated throughout this book and in more detail in the relevant sections. Instead, most of this chapter will focus on the former: abstractions within the model. This chapter introduces technical abstractions that can be utilized as part of model design.

## Abstractions of Analysis

Say we are an insurance company with a portfolio of fixed income assets supporting long term insurance liabilities. We might delineate different levels of abstraction like so:

::: column-margin
![Think about moving up and down a ladder of abstraction when analyzing a problem.](assets/simple_ladder.png)
:::

|               | Item                                                 |
|---------------|------------------------------------------------------|
| More Abstract | Sensitivity of an entire company's solvency position |
|               | Sensitivity of a portfolio of assets                 |
|               | Behavior over time of an individual contract         |
| More granular | Mechanics of an individual bond or insurance policy  |

: An example of the different levels of abstraction when thinking about modeling an insurance company's assets and liabilites. {#tbl-insurance-ladder}

At different times, we are often interested in different aspects of a problem. In general, you start to be able to obtain more insights and a greater understanding of the system when you move up the ladder of abstraction. That insight is often predicated of having a solid understanding of the system at lower levels.

One recurring theme for abstracting the analysis is to consider the effect across different dimensions: time, parameter, variable.

-   **Time** dimension is understanding how the model evolves through time. What is implied by the state of the model at inception or terminal point?
-   **Parameter** dimension refers to how input variables cause changes in outcomes - is there a pattern or shape that indicates a non-obvious relationship?
-   **Variable** dimesion is like parameter, but instead focusing on an interim variable - such as if there's a internal state to the model that leads to a point-of-no-return (e.g. a debt obligation default or a mortality decrement in life insurance). How does the model react to those events?

Much of the rest of the book covers tactical ways to step up this ladder, including:

-   Modeling (@sec-modeling)
-   Automatic Differentiation (@sec-autodiff)
-   Sensitivity Analysis (@sec-sensitivity)
-   Visualization (@sec-visualization)

## Model Abstractions

### Interfaces

**Interfaces** are the boundary between different encapsulated abstractions. For financial model this might mean that there is an interface for bonds, or there is an interface for interest-rate swaps. There may be a different interface for calculating risk metrics or visualizing the results.

Financial model this might mean that there is an interface for bonds, or there is an interface for interest-rate swaps. There may be a different interface for calculating risk metrics or visualizing the results. A better system design will separate the concern of visualizing output from the mechanics of a fixed income contract. This is what it means to put boundaries on different parts of a models logic.

One of the easiest places to see this is with the available open source packages. There are packages available for visualizations, data frames, file, storage, statistical analysis, etc. for many of these it's easy to see where the natural boundary lies, However, it's often difficult to find where to draw lines within financial models. For example, should bonds and interest-rate swaps be in separate packages? Or both part of a broader fixed income package? This is where much of the art and domain expertise of the financial professional comes to bear in modeling. There would be no way for a pure software engineer to think about the right design for the system without understanding how underlying components share, similarities or differences and how those components interact.

#### Conceptual Strategies

Let's consider some stategies that you could think about when deciding where to draw different boundaries inside the model.

##### Behavior-Oriented

This strategies is to effectively group together components with a model that behaves similarly. So, in our example of bonds and interest-rate swaps fundamentally, they share many characteristics and are used in very similar ways within a model. Therefore, it might make sense to group them together when developing a model.

##### Domain Expertise

It may be that components of the model require sufficient expertise that different persons or groups are involved in the development. This may warrant separating a models design, So that different groups contributing to the model can focus on any more narrow aspect, Regardless of inherent similarity of components. For example, at a higher vertical level of obstruction, financial derivatives may fall under similar grouping, but sufficient differences exist for equity credit or foreign exchange derivatives that the model should separate those three asset classes for development purposes.

##### Composability versus All-in-One

For some model design goals, it may be warranted to attempt to bundle together more functionality instead of allowing users to compose a functionality that comes from different packages. For example, perhaps a certain visualization of a model result is particularly useful, It is not easy to create from scratch, And virtually everyone using the model, will desire to see the model output visualized that way. Instead of relying on the user to install a separate visualization package and develop the visualization themselves, it could make sense to bundle visualization functionality with a model that is otherwise unconcerned with graphical capabilities.

In general, though it is preferred to try to loosely couple systems, you can pick and choose which components you use and that those components work well together.

### Programming Interfaces and Patterns

@sec-elements-programming Described a number of tools that we can utilize as interfaces within our model. We use these tools that are provided by our programming language *in service of* the conceptual abstraction described above.

-   Functions let us implement behavior, where we need trouble ourselves with the low level details.
-   Data types provide a hierarchical structure to provide meaning to things, and to group those things together into more meaningful structures.
-   Modules allow us to combine data, and or function, into a related group of concepts which can be shared in different parts of our model

We will also discuss here some **patterns** which are ways of doing things that seem to appear repeatedly and specific design choices have proven to work well in the past and should be considered when similar conditions arise in the future.

Let's develop a simplified system to value simple fixed income assets in order to illustrate some patterns. Inside a module called `Asset`, we'll define a short hiearchy of types and then a function `value` with multiple methods for the relevant types.

```{julia}
#| output: false
module Asset

## Data type definitions
abstract type AbstractAsset end #<1>

struct Cash <: AbstractAsset
    balance::Float64
end

abstract type AbstractBond <: AbstractAsset end #<2>

struct CouponBond <: AbstractBond #<2>
    par::Float64
    coupon::Float64
    tenor::Int
end

struct ZeroCouponBond <: AbstractBond #<2>
    par::Float64
    tenor::Int
end


## Functions

""" 
    value(asset,discount_rate)

The value of an asset with the given discount rate for it's cashflows.
"""
value(asset::Cash, r) = asset.balance

function value(asset::AbstractBond, r) #<4>
    discount_factor = 1.0
    value = 0.0
    for t in 1:asset.tenor
        discount_factor /= (1 + r) # <3>
        value += discount_factor * cashflow(asset, t)
    end
    return value
end

function cashflow(bond::CouponBond, time)
    if time == bond.tenor
        (1 + bond.coupon) * bond.par
    else
        bond.coupon * bond.par
    end
end

function value(bond::ZeroCouponBond, r) # <5>
    return bond.par / (1 + r)^bond.tenor
end

end
```

1.  General convention is to name abstract types beginning with `Abstract...`
2.  We define two simple bonds: a coupon paying and a zero-coupon instrument.
3.  `x /= y`, `x += y`, etc. are shorthand ways to write `x = x / y` or `x = x + y`
4.  `value` is defined for `AbstractBond`s in general...
5.  ... and then more specifically for `ZeroCouponBond`s. This will be explained when discussing "dispatch" below.

Here's an example of how this would be used:

```{julia}
portfolio = [
    Asset.Cash(50.0),
    Asset.CouponBond(100.0, 0.05, 5),
    Asset.ZeroCouponBond(100.0, 5),
]

Asset.value.(portfolio, 0.05)
```

::: callout-note
In the example above, a docstring was included over `value(asset::Cash)` - but not over the others. That's okay. Julia will show docstrings for the *function* `value` not just individual *methods*.
:::

There are quite a few things demonstrated here: dispatch, programming paradigms, and \[!!what else?\] . As each are addressed in turn, we will review how we could have designed the interface differently.

#### (Multiple) Dispatch

When a function is called, the computer has to decide which method to use. In the example above, when we want to `value` a `ZeroCouponBond`, does the `value(asset::AbstractBond, r)` or `value(bond::ZeroCouponBond, r)` version get used? **Dispatch** is the process of determining the right method to use and the rule is that *the most specific defined method gets used*. In this case, that means that even though our `ZeroCouponBond` is an `AbstractBond`, the routine that will used is the more specific `value(bond::ZeroCouponBond, r)`.

Already, this is a powerful tool to simplify our code. Imagine the alternative of a long chain of conditional statements trying to find the right logic to use:

``` julia
# don't do this!
function value(asset,r)
    if asset.type == "ZeroCouponBond"
        # special code for Zero coupon bonds
        # ...
    elseif asset.type == "ParBond"
        # special code for Par bonds
        # ...
    elseif asset.type == "AmortizingBond"
        # special code for Amortizing Bonds
        # ...
    else
        # here define the generic AbstractBond logic
    end
end
```

A more general concept is that of **multiple dispatch**, where the types of *all arguments* are used to determine which method to use. This is a very general paradigm, and in many ways is more extensible than traditional object oriented approaches, (more on that in the next section).

In our definition of `value` above, we used a simple scalar interest rate to determine the rate to discount the cash flows. What if instead of a scalar interest rate value we wanted to instead pass an object that represented a term structure of interest rates? All we have to do is define a new method where the first argument is our `AbstractBond`s as already written above, but the second argument is our new type, which might look like this:

``` julia
struct MyCurve{F} where {F<:Function}
    discount_rate::F
end

function value(bond::ZeroCouponBond, c::MyCurve) # <5>
    return bond.par * c.discount_rate(bond.tenor)
end
```

In this way, multiple dispatch allows us to naturally define methods based on the combination of types.

what if we wanted to extend from a rate to a yield curve and fixed to floating. Where does logic lie? In yield curve or in bond?)

#### Programming Paradigms

**Programming paradigm** refers to the set of structure and concepts used to organize a program. There are many nuances and blurry lines that are encountered in practice, but in broad, conceptual strokes here are the categories that we will discuss:

-   Imperative: explicit definition of the sequence of steps and instructions that control the program's execution flow and modify its state.
    -   Procedural Paradigm: Organization of code into reusable procedures or functions. These procedures can be called and executed from different parts of the program, promoting code modularity and reusability.
    -   Object-Oriented: Object-oriented programming (OOP) revolves around the concept of objects, which encapsulate both data (attributes) and behavior (methods). Objects interact with each other to achieve the desired functionality.
-   Declarative: In contrast to the imperative paradigm, declarative programming focuses on describing the desired results or properties of the program without specifying the detailed steps to achieve them. The language or runtime system determines how to accomplish it[^patterns-abstraction-1].
    -   Functional: Programs are constructed by composing and applying functions to data, avoiding mutable state and side effects. Functions are treated as first-class citizens, meaning they can be passed as arguments, returned as values, and assigned to variables.
    -   Reactive Paradigm: Reactive programming deals with data streams and the propagation of change. It focuses on modeling and reacting to asynchronous data flows and events. In this paradigm, the program reacts to changes in input data and propagates those changes throughout the system, allowing for responsive and event-driven behavior[^patterns-abstraction-2].

[^patterns-abstraction-1]: SQL is an excellent example of this, where one defines what you want as a result rather than defining steps on how to compute the result.

[^patterns-abstraction-2]: Pluto Notebooks (<https://plutojl.org>) are an example of a library that provides a reactive layer on top of Julia, where updating code in one part of the notebook automatically re-runs other code that depends on the modified portion incrementally (instead of needing to re-run the entire notebook).

We will discuss each of these in more detail next.

##### Objected Oriented Design

There's enough general familiarity with object oriented ("OO") design that it's worth describing for understanding how it compares and contrasts to other design patterns. Object oriented systems attempt to form the analogy that various parts of the system are their own objects which encapsulate both data and behavior. Object oriented design is often one the first computer programming abstractions introduced because it very relatable[^patterns-abstraction-3], however this comparative discussion will point out a number of its flaws as well. That said, much of OO design can be emulated in Julia except for data inheritance.

[^patterns-abstraction-3]: "Many people who have no idea how a computer works find the idea of object-oriented programming quite natural. In contrast, many people who have experience with computers initially think there is something strange about object oriented systems.” - David Robson, "Object Oriented Software Systems" in Byte Magazine (1981).

###### Inheritance

We discussed the type hierarchy in @sec-elements-programming and in most OO implementations this hierarchy comes with inheriting both data *and* behavior. This is different from Julia where subtypes inherit behavior but not data from the parent type.

Inheriting the data tends to introduce a tight coupling between the parent and the child classes in OO systems. This tight coupling can lead to several issues, particularly as systems grow in complexity. For example, changes in the parent class can inadvertently affect the behavior of all its child classes, which can be problematic if these changes are not carefully managed. This is often referred to as the "fragile base class problem," where base classes are delicate and changes to them can have widespread, unintended consequences.

Another issue with inheritance in OO design is the temptation to use it for code reuse, which can lead to inappropriate hierarchies. Developers might create deep inheritance structures just to reuse code, leading to a scenario where classes are not logically related but are forced into a hierarchy. This can make the system harder to understand and maintain.

Moreover, inheritance can sometimes lead to the duplication of code across the hierarchy, especially if the inherited behavior needs to be slightly modified in different child classes. This goes against the DRY (Don't Repeat Yourself) principle, which is a fundamental concept in software engineering advocating for the reduction of repetition in code.

#### Composition over Inheritance

To mitigate some of the problems associated with inheritance, there's a growing preference for *composition*. Composition involves creating objects that contain instances of other objects to achieve complex behaviors. This approach is more flexible than inheritance as it allows for the creation of more modular and reusable code. There is a general preference for "composition over inheritance" among professional developers in recent years.

In composition, objects are constructed from other objects, and behaviors are delegated to these contained objects. This approach allows for greater flexibility, as it's easier to change the behavior of a system by replacing parts of it without affecting the entire hierarchy, as is often the case with inheritance.

Composition looks like this:

``` julia
struct CUSIP
    code::string
end

struct FixedIncome
    coupon::Float64
    tenor::Float64
end

struct MunicipalBond
    cusip::CUSIP
    fi::FixedIncome
end

struct ListedOption
    cusip::CUSIP
    #... other data fields
end

struct UnlistedBond
    fi::FixedIncome
end


# define behavior which relies on defining 
last_transaction(c::CUSIP) = # ... perform lookup of data
last_transaction(asset) = last_transaction(asset.cusip)

duration(f::FixedIncome) = # ... calculate duration
duration(asset) = duration(asset.fi)
```

In the above example, there are number of asset classes that have CUSIP related attributes (i.e. the 9 character code) and behavior (e.g. being able to look up transaction data). Other assets have fixed income attributes (e.g. calculating a duration). But not all of these assets have a CUSIP! Composition lets us bundle the data and behavior together without needing complex chains of inheritance.

::: callout-note
A CUSIP (Committee on Uniform Security Identification Procedures) number, is a unique nine-character alphanumeric code assigned to securities, such as stocks and bonds, in the United States and Canada. This code is used to facilitate the clearing and settlement process of securities and to uniquely identify them in transactions and records.
:::

#### Method Dispatch

An alternative and more limiting approach would be to be forced to assign the ownership of the method to one of the associated types, as is done in single-dispatch.

-   Alternative designs:
    -   ZeroCouponBond(par,tenor) = CouponBond(par,0.0,tenor)

#### Functional

#### Other "Paradigms" 

##### Array Oriented

##### DataFrame Oriented

##### Data Driven Design

### Macros & Homoiconicity

### Misc Techniques

#### Recursion

#### Iterators