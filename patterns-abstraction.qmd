# Patterns of Abstraction {#sec-patterns-abstractions}

> "Simple things should be simple, complex things should be possible." — Alan Kay (1970s)

## In this section

We extend the building blocks from the prior section and talk about how to combine them into more abstract patterns to simplify the design of our programs. Data driven design, object oriented design versus composition, multiple dispatch, and interfaces.

## Introduction

In programming and modeling, as in mathematics, abstraction permits the definition of interchangeable components and patterns that can be reused. Abstraction is a selective ignorance—focusing on the aspects of the problem that are relevant, and ignoring the others. 

## Interfaces

**Interfaces** are the boundary between different encapsulated abstractions. Financial model this might mean that there is an interface for bonds, or there is an interface for interest-rate swaps. There may be a different interface for calculating risk metrics or visualizing the results.

Financial model this might mean that there is an interface for bonds, or there is an interface for interest-rate swaps. There may be a different interface for calculating risk metrics or visualizing the results. A better system design will separate the concern of visualizing output from the mechanics of a fixed income contract. This is what it means to put boundaries on different parts of a models logic.

One of the easiest places to see this is with the available open source packages. There are packages available for visualizations, data frames, file, storage, statistical analysis, etc. for many of these it's easy to see where the natural boundary lies, However, it's often difficult to find where to draw lines within financial models. For example, should bonds and interest-rate swaps be in separate packages? Or both part of a broader fixed income package? This is where much of the art and domain expertise of the financial professional comes to bear in modeling. There would be no way for a pure software engineer to think about the right design for the system without understanding how underlying components share, similarities or differences and how those components interact.

### Conceptual Strategies

Let's consider some stategies that you could think about when deciding where to draw different boundaries inside the model.

#### Behavior-Oriented

This strategies is to effectively group together components with a model that behaves similarly. So, in our example of bonds and interest-rate swaps fundamentally, they share many characteristics and are used in very similar ways within a model. Therefore, it might make sense to group them together when developing a model.

#### Domain Expertise

It may be that components of the model require sufficient expertise that different persons or groups are involved in the development. This may warrant separating a models design, So that different groups contributing to the model can focus on any more narrow aspect, Regardless of inherent similarity of components. For example, at a higher vertical level of obstruction, financial derivatives may fall under similar grouping, but sufficient differences exist for equity credit or foreign exchange derivatives that the model should separate those three asset classes for development purposes.

#### Composability versus All-in-One

For some model design goals, it may be warranted to attempt to bundle together more functionality instead of allowing users to compose a functionality that comes from different packages. For example, perhaps a certain visualization of a model result is particularly useful, It is not easy to create from scratch, And virtually everyone using the model, will desire to see the model output visualized that way. Instead of relying on the user to install a separate visualization package and develop the visualization themselves, it could make sense to bundle visualization functionality with a model that is otherwise unconcerned with graphical capabilities.

In general, though it is preferred to try to loosely couple systems, you can pick and choose which components you use and that those components work well together.

## Programming Interfaces and Patterns

@sec-elements-programming Described a number of tools that we can utilize as interfaces within our model. We use these tools that are provided by our programming language *in service of* the conceptual abstraction described above.

-   Functions let us implement behavior, where we need trouble ourselves with the low level details.
-   Data types provide a hierarchical structure to provide meaning to things, and to group those things together into more meaningful structures.
-   Modules allow us to combine data, and or function, into a related group of concepts which can be shared in different parts of our model

We will also discuss here some **patterns** which are ways of doing things that seem to appear repeatedly and specific design choices have proven to work well in the past and should be considered when similar conditions arise in the future.


## Macros & Homoiconicity

## Misc Techniques

### Recursion

### Iterators

#### Currying, or Partially Evaluated Functions

An advanced technique that shows off the first class nature of a special kind of functions: curried or partially evaluated functions are multi-argument functions where part of the function's arguments have already been defined so that they can be used more convieniently. 

Here's some examples of how to do this with a test of equality. Say we want to later test if something is greater than or equal to 2. For example:

```{julia}
10 >= 2
```

We could also use these alternatively defined versions:

```{julia}
let
    f1 = x -> x >= 2 # <1>
    f2 = >=(2)
    f3 = Base.Fix2(>=,2) # <2>

    f1(10), f2(10), f3(10)

end
```
1. Not really a partially evaluated form, since there's only a single argument involved.
2. From the manual: "`Base.Fix2` is a type representing a partially-applied version of the two-argument function `f`, with the second argument fixed to the value "x". In other words, `Fix2(f, x)` behaves similarly to `y->f(y, x)`."


Why is this convienent?

A generic example is filtering a collection, such as: 

```{julia}
filter(>=(2),[1,10,20,4])
```

Another use-case that would come up in financial applications. Say that you had a function `interpolate((xs,ys),x)` which took two arguments: 
1. a tuple of input values with associated output values, and
2. an argument for the new input that you want to calculate the interpolated value for.

This might look like this:

```julia
function interpolate(data,x)
 # ... code to perform the interpolation 
 # such that f(x) represents represents the 
 # desired interpolated value
 return f(x)
end

# get a function that will provide interpolated rates
my_curve = Base.Fix1(interpolate,(maturities,rates))

# get the rate assocated with time 1.5
my_curve(1.5) 
```

You probably don't want to do this exact thing if the runtime to calculate the interpolation is expensive, but the technique comes up sometimes when trying to wrtie more general code.