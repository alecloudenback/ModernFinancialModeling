# Patterns of Abstraction {#sec-patterns-abstractions}

> "Simple things should be simple, complex things should be possible." — Alan Kay (1970s)

## In this section

Why we talk about abstraction as a technique in and of itself, discussion of abstraction at the level of code organizaiton and interfaces.

## Introduction

In programming and modeling, as in mathematics, abstraction permits the definition of interchangeable components and patterns that can be reused. Abstraction is a selective ignorance—focusing on the aspects of the problem that are relevant, and ignoring the others. The last two chapters described what we might call "micro" level abstractions: specific functions or types. In this chapter, we zoom out and examine some principles that guide good model development and how that manifests itself in architectural conerns such as how different parts of the code are organized, what parts of the program are considered 'public' versus 'private', and patterns themselves.

## Principles for Abstraction

Here is a list of some principles that arise when developing a particular abstraction. Not all abstractions serve all of these purposes but generally fit one or more of them.

1. Separation of Concerns
   - What: Divide the system into distinct parts, each addressing a separate concern
   - Why: Promote modularity and reduce high degree of dependence (coupling) between components
   - Example: Separating data retrieval, data processing, and output generation steps in a process

2. Encapsulation
   - What: Hide the internal details of a component and expose only a clean, well-defined set of functionality (interface)
   - Why: Don't let other parts of the program modify internal data and make the system easier to understand and maintain
   - Example: Defining a type or module with well defined behavior and responsibiltiy

3. Composability
   - What: Design simple components that can be combined to create more complex behaviors, as opposed to a single component that attempts to handle all behavior.
   - Why: Promote reuse and allow for the components to be combined creatively
   - Example: Separate details about economic conditions into different types than contracts/instruments

4. Generalization
   - What: Identify common patterns and create generic components that can be specialized as needed. Often this means idenfifying the common behavior that arises repeatedly in a model
   - Why: Avoid duplication and make the system more expressive and extensible
   - Example: Defining a generic `Instrument` type that can be specialized for different asset classes

These principles provide guidance for creating abstractions that are modular, reusable, and maintainable. By following these principles, developers can create financial models that are easier to understand, extend, and adapt to changing requirements.

### Pragramatic Considerations for Model Design

#### Behavior-Oriented

This strategies is to effectively group together components with a model that behaves similarly. So, in our example of bonds and interest-rate swaps fundamentally, they share many characteristics and are used in very similar ways within a model. Therefore, it might make sense to group them together when developing a model.

#### Domain Expertise

It may be that components of the model require sufficient expertise that different persons or groups are involved in the development. This may warrant separating a models design, So that different groups contributing to the model can focus on any more narrow aspect, Regardless of inherent similarity of components. For example, at a higher vertical level of obstruction, financial derivatives may fall under similar grouping, but sufficient differences exist for equity credit or foreign exchange derivatives that the model should separate those three asset classes for development purposes.

#### Composability versus All-in-One

For some model design goals, it may be warranted to attempt to bundle together more functionality instead of allowing users to compose a functionality that comes from different packages. For example, perhaps a certain visualization of a model result is particularly useful, It is not easy to create from scratch, And virtually everyone using the model, will desire to see the model output visualized that way. Instead of relying on the user to install a separate visualization package and develop the visualization themselves, it could make sense to bundle visualization functionality with a model that is otherwise unconcerned with graphical capabilities.

In general, though it is preferred to try to loosely couple systems, you can pick and choose which components you use and that those components work well together.

## Interfaces

**Interfaces** are the boundary between different encapsulated abstractions. Financial model this might mean that there is an interface for bonds, or there is an interface for interest-rate swaps. There may be a different interface for calculating risk metrics or visualizing the results.

Financial model this might mean that there is an interface for bonds, or there is an interface for interest-rate swaps. There may be a different interface for calculating risk metrics or visualizing the results. A better system design will separate the concern of visualizing output from the mechanics of a fixed income contract. This is what it means to put boundaries on different parts of a models logic.

One of the easiest places to see this is with the available open source packages. There are packages available for visualizations, data frames, file, storage, statistical analysis, etc. for many of these it's easy to see where the natural boundary lies, However, it's often difficult to find where to draw lines within financial models. For example, should bonds and interest-rate swaps be in separate packages? Or both part of a broader fixed income package? This is where much of the art and domain expertise of the financial professional comes to bear in modeling. There would be no way for a pure software engineer to think about the right design for the system without understanding how underlying components share, similarities or differences and how those components interact.


## Programming Interfaces and Patterns

@sec-elements-programming Described a number of tools that we can utilize as interfaces within our model. We use these tools that are provided by our programming language *in service of* the conceptual abstraction described above.

-   Functions let us implement behavior, where we need trouble ourselves with the low level details.
-   Data types provide a hierarchical structure to provide meaning to things, and to group those things together into more meaningful structures.
-   Modules allow us to combine data, and or function, into a related group of concepts which can be shared in different parts of our model

We will also discuss here some **patterns** which are ways of doing things that seem to appear repeatedly and specific design choices have proven to work well in the past and should be considered when similar conditions arise in the future.


## Macros & Homoiconicity

## Misc Techniques

