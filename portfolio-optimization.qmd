---
author:
- name: Yun-Tien Lee
---

# Portfolio Optimization {#sec-portfolio-optimization}

> "Portfolio optimization is not about finding the perfect mix, but about managing risk and return in a way that aligns with your goals and circumstances." — Unknown

## Chapter Overview

Optimization in a portfolio context with examples of asset selection under different constraints and objectives.

```{julia}
#| echo: false
#| output: false
using Pkg
Pkg.activate("env/pf_opt")
Pkg.instantiate()
```

## The Data

We will use an example portfolio throughout the chapter, which contains three assets whose returns and covariances between the assets are listed below.

```{julia}
μ = [0.1, 0.15, 0.12] # returns
Σ = [0.1 0.05 0.03;
    0.05 0.12 0.04;
    0.03 0.04 0.08] # covariances
nₐ = length(μ) # number of assets
```

## Theory

Harry Markowitz introduced the modern portfolio theory in 1952. The main idea is that investors are pursuing to maximize their expected return of a portfolio given a certain amount of risk. Under standard assumptions, achieving higher expected returns typically requires accepting higher risk; portfolios that simultaneously deliver higher return and lower risk are dominated and lie above the feasible set. The efficient frontier traces the best achievable trade-off.

## Mathematical tools

### Mean-variance optimization model

Mean-variance optimization is a mathematical framework that seeks to maximize expected returns while minimizing portfolio variance (or standard deviation). It involves calculating the expected return and risk of individual assets and finding the optimal combination of assets to achieve the desired risk-return tradeoff.

$$
\begin{aligned}
\text{minimize} \quad &{w}^{T}\Sigma{w}\\
\text{subject to} \quad &{r}^{T}{w}\geq{\mu}_{\text{target}}\\
&{1}^{T}{w}={1}\\
&{w}\geq{0}
\end{aligned}
$$

```{julia}
using JuMP, Ipopt, LinearAlgebra

# Create an optimization model
model = Model(Ipopt.Optimizer)
set_silent(model)
# Set up weights as variables to optimize
@variable(model, w[1:nₐ] >= 0.0)
# Objective: minimize portfolio variance
@objective(model, Min, dot(w, Σ * w))
# Constraints: Sum of portfolio weights should equal to 1, and all weights should be zero or positive
@constraint(model, sum(w) == 1.0)
# May also add additional constraints
# target_return = 0.1
# @constraint(model, dot(μ, w) >= target_return)
# Solve the optimization problem
optimize!(model)
w_meanvar = value.(w)
μ_meanvar = dot(μ, w_meanvar)
σ_meanvar = sqrt(dot(w_meanvar, Σ * w_meanvar))

# Print results
println("Optimal minimum mean-variance portfolio weights:")
for (i, wᵢ) in enumerate(w_meanvar)
    println("Asset ", i, ": ", round(wᵢ, digits=4))
end
println("Portfolio mean optimized under mean-variance = ", round(μ_meanvar, digits = 4))
println("Portfolio standard deviation optimized under mean-variance = ", round(σ_meanvar, digits = 4))
```

In mean-variance portfolio optimization, incorporating a cost of risk-based capital on assets is a practical consideration that reflects the additional capital required to support riskier assets in a portfolio. This approach ensures that the optimization process not only maximizes returns relative to risk but also considers the regulatory or internal cost implications associated with holding riskier assets.

$$
\begin{aligned}
\text{maximize} \quad &{w}^{T}R_{adj}\\
\text{subject to} \quad &{w}^{T}\Sigma{w}\le\sigma^2_{max}\\
&{1}^{T}{w}={1}\\
&{w}\geq{0}
\end{aligned}
$$

where $R_{adj} = [(\mu_1 - \lambda_1), (\mu_2 - \lambda_2), ..., (\mu_N - \lambda_N)]$ is the adjusted expected returns.

```{julia}
using JuMP, Ipopt, LinearAlgebra

# Create an optimization model
model = Model(Ipopt.Optimizer)
set_silent(model)
λ = [0.01, 0.02, 0.05]  # RBC cost per asset
r = μ .- λ # risk adjusted returns
σ²_max = 0.1 # maximum portfolio variance
# Set up weights as variables to optimize
@variable(model, w[1:nₐ] >= 0.0)
# Objective: minimize portfolio variance
@objective(model, Max, dot(r, w))
# Constraints: Sum of portfolio weights should equal to 1, and all weights should be zero or positive
@constraint(model, sum(w) == 1.0)
# Constraints: Sum of allowable portfolio variance is limited
@constraint(model, dot(w, Σ * w) <= σ²_max)
# May also add additional constraints
# target_return = 0.1
# @constraint(model, dot(μ, w) >= target_return)
# Solve the optimization problem
optimize!(model)
w_rbc = value.(w)
μ_rbc = dot(μ, w_rbc)
σ_rbc = sqrt(dot(w_rbc, Σ * w_rbc))

# Print results
println("Portfolio weights with RBC-adjusted returns:")
for (i, wᵢ) in enumerate(w_rbc)
    println("Asset ", i, ": ", round(wᵢ, digits=4))
end
println("Portfolio mean optimized under RBC = ", round(μ_rbc, digits = 4))
println("Portfolio standard deviation optimized under RBC = ", round(σ_rbc, digits = 4))
```

### Efficient frontier analysis

The efficient frontier represents the set of portfolios that offer the highest expected return for a given level of risk or the lowest risk for a given level of return. Efficient frontier analysis involves plotting risk-return combinations for different portfolios and identifying the optimal portfolio on the frontier.

```{julia}
using JuMP, Ipopt, CairoMakie, LinearAlgebra
import MathOptInterface as MOI

function efficient_frontier(μ, Σ; points::Int = 100)
    targets = range(minimum(μ), maximum(μ), length = points)
    frontier = Tuple{Float64, Float64}[]
    for target in targets
        model = Model(Ipopt.Optimizer)
        set_silent(model)
        n = length(μ)
        @variable(model, w[1:n] >= 0.0)
        @objective(model, Min, dot(w, Σ * w))
        @constraint(model, sum(w) == 1.0)
        @constraint(model, dot(μ, w) == target)
        optimize!(model)
        status = termination_status(model)
        if status in (MOI.LOCALLY_SOLVED, MOI.OPTIMAL)
            push!(frontier, (sqrt(objective_value(model)), target))
        end
    end
    frontier
end

ef = efficient_frontier(μ, Σ)
# Plot Efficient Frontier
fig = Figure()
Axis(fig[1, 1], xlabel = "Portfolio Volatility (σ)", ylabel = "Expected Return (μ)")
lines!(first.(ef), last.(ef), color = :dodgerblue, linewidth = 2)
fig
```

### Black-Litterman

The Black-Litterman model combines the views of investors with market equilibrium assumptions to generate optimal portfolios. It starts with a market equilibrium portfolio and adjusts it based on investor views and confidence levels. The model incorporates subjective opinions while maintaining diversification and risk management principles.

$$
\begin{aligned}
\text{maximize} \quad & \mu_{BL}^{T} w \;-\; \frac{\lambda}{2}\, w^{T} \Sigma \, w \\
\text{subject to} \quad & \sum_{i=1}^{N} w_i = 1 \\
& w_i \geq 0, \quad \forall i \\
\text{where} \mu_{BL} = \\
\Big( (\tau \Sigma)^{-1} + P^{T} \Omega^{-1} P \Big)^{-1}
\Big( (\tau \Sigma)^{-1} \mu + P^{T} \Omega^{-1} Q \Big)
\end{aligned}
$$

$μ$ = prior (implied) returns from the market equilibrium.
$P$ = matrix encoding which assets your views are on.
$Q$ = your views (expected returns for specific portfolios).
$Ω$ = uncertainty (covariance) of your views.
$τ$ = scaling factor for the prior covariance (usually small, like 0.025).

```{julia}
using JuMP, Ipopt, LinearAlgebra

# Market equilibrium parameters (prior)
λ = 2.5 # risk aversion
μ_market = fill(0.08, nₐ) # Market equilibrium return
Σ_prior = Σ # Market equilibrium covariance matrix
# Investor views
Q = μ # Expected returns on assets according to investor views
P = Matrix(I, nₐ, nₐ) # Pick matrix specifying which assets views are on
Ω = Diagonal([1e-6, 4e-6, 9e-6])  # Views uncertainty (covariance matrix)
τ = 0.05 # Scaling factor

# Black-Litterman expected return adjustment
Σ_inv = inv(Σ_prior)
# Calculate the posterior expected returns
A = Σ_inv / τ + P' * (Ω \ P)
B = Σ_inv * μ_market / τ + P' * (Ω \ Q)
μ_BL = A \ B

# Create an optimization model
model = Model(Ipopt.Optimizer)
set_silent(model)
# Set up weights as variables to optimize
@variable(model, w[1:nₐ] >= 0.0)
# Objective: maximize sharpe ratio
@objective(model, Max, dot(μ_BL, w) - (λ / 2) * dot(w, Σ_prior * w))
# Constraints: Sum of portfolio weights should equal to 1, and all weights should be zero or positive
@constraint(model, sum(w) == 1.0)
# Solve the optimization problem
optimize!(model)
w_BL = value.(w)
μ_BLpost = dot(μ_BL, w_BL)
σ_BLpost = sqrt(dot(w_BL, Σ_prior * w_BL))
# Print results
println("Portfolio standard deviation optimized under Black-Litterman = ", round(σ_BLpost, digits = 4))
for (i, wᵢ) in enumerate(w_BL)
    println("Asset ", i, ": ", round(wᵢ, digits=4))
end
println("Portfolio Weights optimized under Black-Litterman:")
println("Portfolio mean optimized under Black-Litterman = ", round(μ_BLpost, digits = 4))
```

### Risk Parity

Risk parity is an asset allocation strategy that allocates capital based on risk rather than traditional measures such as market capitalization or asset prices. It aims to balance risk contributions across different assets or asset classes to achieve a more stable portfolio. Risk parity portfolios often include assets with different risk profiles, such as stocks, bonds, and commodities.

$$
\begin{aligned}
\min_{w \in \mathbb{R}^N} \quad & \sum_{i=1}^{N} \left( RC_i - t \right)^2 \\
\text{subject to} \quad & \sum_{i=1}^{N} w_i = 1, \\
& w_i \ge 0, \quad i = 1, \dots, N \\
\text{where} \quad
RC_i = \frac{w_i (\Sigma w)_i}{w^{T} \Sigma w + \epsilon}
\end{aligned}
$$

```{julia}
using JuMP, Ipopt, LinearAlgebra

# Create an optimization model
model = Model(Ipopt.Optimizer)
set_silent(model)
# Set up weights as variables to optimize
@variable(model, w[1:nₐ] >= 0.0)
# Objective: minimize portfolio variance
@expression(model, Σw[i=1:nₐ], sum(Σ[i, j] * w[j] for j in 1:nₐ))
@expression(model, var_p, sum(w[i] * Σw[i] for i in 1:nₐ))
@expression(model, RC[i=1:nₐ], (w[i] * Σw[i]) / (var_p + eps()))
@expression(model, target_contribution, var_p / nₐ)
@objective(model, Min, sum((RC[i] - target_contribution)^2 for i in 1:nₐ))
# Constraints: Sum of portfolio weights should equal to 1, and all weights should be zero or positive
@constraint(model, sum(w) == 1.0)
# Solve the optimization problem
optimize!(model)
w_rp = value.(w)
Σw_val = Σ * w_rp
rc = w_rp .* Σw_val
rc_share = rc ./ sum(rc)
# Print results
println("Optimal portfolio weights under risk parity:")
for (i, wᵢ) in enumerate(w_rp)
    println("Asset ", i, ": ", round(wᵢ, digits=4))
    println("RC share ", i, ": ", round(rc_share[i], digits=4))
end
```

Each asset contributes one third of total portfolio variance at the optimum, a hallmark of risk parity construction. Compared with the minimum-variance allocation, the solution spreads weight more evenly because it penalizes large disparities in marginal risk contributions.

### Sharpe Ratio Maximization

The Sharpe ratio measures the risk-adjusted return of a portfolio and is calculated as the ratio of excess return to volatility. Maximizing the Sharpe ratio involves finding the portfolio allocation that offers the highest risk-adjusted return. This approach focuses on achieving the best tradeoff between risk and return.

$$
\begin{aligned}
\text{maximize} \quad & \frac{E[R_p] - rfr}{\sigma_p} \\
\text{subject to} \quad & \sum_{i=1}^{N} w_i = 1 \\
& w_i \geq 0, \quad \forall i
\end{aligned}
$$

```{julia}
using JuMP, Ipopt, LinearAlgebra

# Create an optimization model
model = Model(Ipopt.Optimizer)
set_silent(model)
# Set up weights as variables to optimize
@variable(model, w[1:nₐ] >= 0.0)
# Objective: minimize portfolio variance
rfr = 0.05 # risk free rate
@objective(model, Max, (dot(μ, w) - rfr) / sqrt(sum(w[i] * Σ[i, j] * w[j] for i in 1:nₐ, j in 1:nₐ) + eps()))
# Constraints: Sum of portfolio weights should equal to 1, and all weights should be zero or positive
@constraint(model, sum(w) == 1.0)
# Solve the optimization problem
optimize!(model)
w_sharpe = value.(w)
μ_sharpe = dot(μ, w_sharpe)
σ_sharpe = sqrt(dot(w_sharpe, Σ * w_sharpe))
sharpe_ratio = (μ_sharpe - rfr) / σ_sharpe

# Print results
println("Optimal portfolio weights using Sharpe Ratio:")
for (i, wᵢ) in enumerate(w_sharpe)
    println("Asset ", i, ": ", round(wᵢ, digits=4))
end
println("Sharpe ratio = ", round(sharpe_ratio, digits = 4))
println("Portfolio mean optimized using Sharpe Ratio = ", round(μ_sharpe, digits = 4))
println("Portfolio standard deviation optimized using Sharpe Ratio = ", round(σ_sharpe, digits = 4))
```

### Robust Optimization

Robust optimization techniques aim to create portfolios that are resilient to uncertainties and fluctuations in market conditions. These techniques consider a range of possible scenarios and optimize portfolios to perform well across different market environments. A robust parameter in robust portfolio optimization is typically chosen to ensure the portfolio's performance remains stable and satisfactory under different market conditions or variations in input data. Robust optimization may involve incorporating stress tests, scenario analysis, or robust risk measures into the portfolio construction process.

$$
\begin{aligned}
\text{minimize} \quad & w^T \Sigma w + \gamma \|w - w_0\|_2^2 \\
\text{subject to} \quad & \sum_{i=1}^{N} w_i = 1 \\
& w_i \geq 0, \quad \forall i \\
& \|(\Sigma^{1/2} (w - w_0))\|_2 \leq \epsilon
\end{aligned}
$$

```{julia}
using JuMP, Ipopt, LinearAlgebra

# Create an optimization model
model = Model(Ipopt.Optimizer)
set_silent(model)
# Set up weights as variables to optimize
@variable(model, w[1:nₐ] >= 0.0)
# Objective: minimize portfolio variance
ε = 0.05  # Uncertainty level
γ = 0.1  # Robustness parameter
w₀ = [0.3, 0.4, 0.3] # expected weights
@objective(model, Min, dot(w, Σ * w) + γ * sum((w[i] - w₀[i])^2 for i in 1:nₐ))
# Constraints: Sum of portfolio weights should equal to 1, and all weights should be zero or positive
@constraint(model, sum(w) == 1)
@constraint(model, sum(((w[i] - w₀[i]) * Σ[i, j] * (w[j] - w₀[j])) for i in 1:nₐ, j in 1:nₐ) <= ε)
# Solve the optimization problem
optimize!(model)
w_robust = value.(w)
μ_robust = dot(μ, w_robust)
σ_robust = sqrt(dot(w_robust, Σ * w_robust))
# Print results
println("Portfolio Weights under robust optimization:")
for (i, wᵢ) in enumerate(w_robust)
    println("Asset ", i, ": ", round(wᵢ, digits=4))
end
println("Portfolio mean under robust optimization = ", round(μ_robust, digits = 4))
println("Portfolio standard deviation under robust optimization = ", round(σ_robust, digits = 4))
```

### Asset weights from different methodologies

| Methodology            | Asset weights      |
|------------------------|--------------------|
| Standard mean variance | [0.33, 0.17, 0.50] |
| (with RBC costs)       | [0.17, 0.83, 0.00] |
| Black-Litterman        | [0.18, 0.34, 0.48] |
| Risk parity            | [0.33, 0.30, 0.37] |
| Sharpe ratio           | [0.02, 0.53, 0.45] |
| Robust                 | [0.31, 0.31, 0.38] |
: Optimized asset weights from different methodologies {.striped .hover}

Seeing from the asset weights from a standard mean variance approach, due to RBC costs asset weights shifted to ones with higher yields. Asset weights from Sharpe ratio approach aligns with the Sharpe ratio for each asset. Those from Robust approach seek results not far away from expected weights under different conditions.

## Practical considerations

### Fractional purchases of assets

In traditional portfolio optimization, fractional purchases of assets refer to the ability to allocate fractions or percentages of capital to individual assets. However, in certain contexts or practical implementations, fractional purchases may not be allowed or considered.

- Practical constraints. Some investment vehicles or platforms may restrict investors from purchasing fractions of shares or assets. For instance, certain mutual funds, exchange-traded funds (ETFs), or other investment products may require whole units of shares to be purchased.

- Simplicity and cost-effectiveness. Handling fractional shares can add complexity and operational costs to portfolio management, especially in terms of transaction fees, administrative overhead, and reconciliation processes.

- Market liquidity. Some assets may have limited liquidity or trading volumes, making it impractical or difficult to execute fractional purchases without significantly impacting market prices or transaction costs.

- Regulatory considerations. Regulations in certain jurisdictions may impose restrictions on fractional share trading or ownership, potentially limiting the ability to include fractional purchases in portfolio optimization strategies.

### Large number of assets

In portfolio optimization, a penalty factor for a large volume of assets typically refers to a mechanism or adjustment applied to the optimization process to mitigate the potential biases or challenges that arise when dealing with a large number of assets. This concept is particularly relevant in the context of mean-variance optimization and other optimization frameworks where computational efficiency and practical portfolio management considerations come into play. Too many assets may have the following issues.

- Dimensionality. As the number of assets (or dimensions) increases in a portfolio, traditional optimization methods may become computationally intensive or prone to overfitting. This is because the complexity of the optimization problem grows exponentially with the number of assets.

- Sparsity and concentration. In practice, not all assets may contribute equally to portfolio performance. Some assets may have negligible impact on the overall portfolio characteristics (such as risk or return) due to low weights or correlations with other assets.

- Penalizing excessive complexity. A penalty factor can be introduced to penalize portfolios that overly diversify or allocate small weights to a large number of assets. This encourages the optimization process to focus on more significant assets or reduce the complexity of the portfolio structure.

There are various ways to implement a penalty factor for a large volume of assets:

- Regularization techniques. Techniques like Lasso (L1 regularization) or Ridge (L2 regularization) regression can penalize small weights or excessive diversification by adding a penalty term to the objective function.
- Subset selection. Methods that explicitly select a subset of assets based on their contribution to portfolio performance, rather than including all assets indiscriminately.
- Heuristic adjustments. Introducing heuristic rules or adjustments based on practical portfolio management principles or empirical observations.
